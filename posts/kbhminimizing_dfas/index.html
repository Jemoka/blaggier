<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><meta name=viewport content="width=device-width,initial-scale=1"><script src=https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4></script><link rel=preconnect href=https://fonts.bunny.net><link href="https://fonts.bunny.net/css?family=ibm-plex-sans:300,400,400i,500,500i,600,700,700i" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>Minimizing DFAs</title>
<meta name=description content="The fact that DFAs are limited, it allows us to optimize a DFA. Specifically, we ask: &ldquo;does this DFA have a minimal number of states?&rdquo;
Formally: can we accept the same language with a particular DFA with another DFA with less states?

For every language \(L\), there is a unique (up to state relabeling) minimal-state DFA \(M^{*}\) such that \(L(M^{*}) = L\).
Furthermore, there exists an efficient algorithm which, given DFA \(M\), will produce this unique \(M^{*}\)."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/all.css><link rel=stylesheet href=/css/page.css><link rel=stylesheet href=/css/syntax.css><link rel=stylesheet href=/css/typography.css><link rel=stylesheet href=/css/components.css></head><body><div class="center-clearfix p-10" style="max-width:1200px;margin:0 auto"><header class=pb-4><span class="w-full flex justify-between flex-wrap"><div style=font-weight:600;font-size:15px><a style=border:0;cursor:pointer href=/><img src=/images/Logo_Transparent.png style=width:17px;display:inline-block;margin-right:8px;transform:translateY(-2.7px)></a>Minimizing DFAs</div><span style="float:right;display:flex;align-items:center;margin-top:5px;width:100%;max-width:400px;background:#fff;border-radius:2px;border:1px solid var(--gray-2);position:relative"><i class="fa-solid fa-magnifying-glass" style=font-size:12px;color:var(--yellow-fg);margin-right:7px;margin-left:10px></i><div style=width:100%><input id=search-query-inline name=s type=text autocomplete=off placeholder="Search Knowledgebase" enterkeyhint=search></div><div id=search-result-inline style=display:none></div><script id=search-result-template type=text/x-js-template data-template=searchresult>
    <a href="${link}" class="search-link">
    <div class="search-result-item" id="search-result-item-${key}">
        <div class="search-result-title">${title}</div>
        <div class="search-result-summary">${snippet}</div>
    </div>
    </a>
</script><script src=https://code.jquery.com/jquery-3.3.1.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.0/fuse.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js></script><script type=module>
    import { create, insertMultiple, search } from 'https://cdn.jsdelivr.net/npm/@orama/orama@latest/+esm'
    let template = $('script[data-template="searchresult"]').text().split(/\$\{(.+?)\}/g);

    function render(props) {
        return function(tok, i) { return (i % 2) ? props[tok] : tok; };
    }

    const db = create({
        schema: {
            title: 'string',
            content: 'string',
        },
    });
    $.get("https://www.jemoka.com/index.json", function(data, status){
        insertMultiple(db, data.map(x =>
            ({title: x.title, content: x.contents, link: x.permalink})));
    });
    $("#search-result-inline").attr("tabindex", "-1");
    $(document).on("click", function (e) {
    if (!$(e.target).closest("#search-query-inline, #search-result-inline").length) {
        $("#search-result-inline").hide();
    }
    });
    
    
    
    
    
    

    $("#search-query-inline").on("focus keyup", function () {
        let value = $(this).val();
        if (value.trim() == "") {
            $("#search-result-inline").html("");
            $("#search-result-inline").hide();
            return;
        }
        $("#search-result-inline").show();
        let results = search(db, {mode: "fulltext", term: value});
        let contents = results.hits.map(x => template.map(render({
            title: x.document.title,
            snippet: x.document.content.slice(0, 52),
            key: x.id,
            link: x.document.link
        })).join(''));
        $("#search-result-inline").html(contents.join("\n"));
        
    });
    if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        $('#search-query-inline').on('focus', function(){
            
            $(this).data('fontSize', $(this).css('font-size')).css('font-size', '16px');
        }).on('blur', function(){
            
            $(this).css('font-size', $(this).data('fontSize'));
        });
    }

</script></span></span><div class=w-full style="padding-bottom:4px;border-bottom:1px solid var(--gray-1);margin-top:1px"></div></header><aside id=tocbox><div id=heading style=padding-left:40px;font-weight:600;font-size:11px;color:var(--gray-3)>contents</div><div id=toc></div></aside><main><article><div style=max-width:700px><p>The fact that <a href=/posts/kbhdeterministic_finite_automata/>DFA</a>s are limited, it allows us to optimize a <a href=/posts/kbhdeterministic_finite_automata/>DFA</a>. Specifically, we ask: &ldquo;does this DFA have a minimal number of states?&rdquo;</p><p>Formally: <strong>can we accept the same language with a particular DFA with another DFA with less states?</strong></p><hr><p>For every language \(L\), there is a <strong>unique</strong> (up to state relabeling) minimal-state DFA \(M^{*}\) such that \(L(M^{*}) = L\).</p><p>Furthermore, there exists an efficient algorithm which, given DFA \(M\), will produce this unique \(M^{*}\).</p><p>(btw; there isn&rsquo;t a uniquely minimal <a href=/posts/kbhnondeterministic_finite_automata/>NFA</a>)</p><hr><p>Now let&rsquo;s show it; in many parts.</p><h2 id=extending-delta>extending \(\delta\)</h2><p>Given a DFA, we want to extend its transition function to \(\Delta: Q \times \Sigma \to Q\) (i.e. string transitions instead of character transitions)</p><p>\begin{align}
&\Delta (q, \varepsilon) = q \\
&\Delta (q, \sigma) = \delta(q, \sigma) \\
&\Delta (q, \sigma_{1} \dots \sigma_{k+1}) = \delta(\Delta(q, \sigma_{1} \dots\sigma_{k}), \sigma_{k+1})
\end{align}</p><p>Meaning, \(\Delta(q,w)\) is the state \(M\) reached after reading \(w\), starting from state \(q\). Meaning, \(\Delta(q_0, w) \in F\) means <a href=/posts/kbhequivalence/>IFF</a> that \(w \in L(M)\).</p><p>So: \(w \in \Sigma^{*}\) distinguishes states \(q_1, q_2\) if $Δ(q_1, w) ∈ F ⇔ Δ(q_2, w) ¬ ∈ F$&mdash;this is because if the right is true, passing \(w\) at each of those states do not allow you to forget where you started with (as transitions of both after \(q_1\) and \(q_2\) are the same). Hence, those states are distinguished by \(w\). That is, \(w\) allows you to tell which one of \(q_1\) or \(q_2\) you are in.</p><h2 id=distinguishable-states>distinguishable states</h2><p>We define state \(p\) as <strong>distinguishable</strong> from state \(q\) if there exists some \(w \in \Sigma^{*}\) such that exactly one of \(\Delta(p,w)\) or \(\Delta(q,w)\) is an accept state. That is, \(w\) distinguishes \(p\) and \(q\).</p><p>This means that these two states have a <strong>different function</strong>: you can&rsquo;t merge them.</p><p>Conversely, state \(p\) and \(q\) are <strong>indistinguishable</strong> if they are not distinguishable; that is, for all \(w \in \Sigma^{*}\), \(\Delta(p,w) \in F \Leftrightarrow \Delta(q,w) \in F\).</p><p>Indistinguishable states are redundant.</p><h2 id=4c761f>~</h2><p>Let us define a binary relation ~ on the states of \(M\). Specifically, \(p \sim q\) IFF \(p\) is <strong>indistinguishable</strong> from \(q\). That is, \(p \not\sim q\) if \(p\) is distinguishable from \(q\).</p><p>\(\sim\) is an <a href=/posts/kbhequivalence_relation/>equivalence relation</a>.</p><h2 id=state-partitioning>state partitioning</h2><p>since ~ is an equivalence relation, we can partition states \(Q\) into disjoint equivalence classes.</p><p>that is, each of the equivalence relation for \(q\) means that \([q] := \qty {p | p \sim q}\); because of transitivity, naming any element of this group will give you the whole group.</p><h2 id=dfa-minimization-algorithm>DFA minimization algorithm</h2><ul><li><strong>input</strong>: DFA \(M\)</li><li><strong>output</strong>: DFA \(M_{\min}\) such that&mldr;<ul><li>\(L(M) = L\qty(M_{MIN})\)</li><li>\(M_{MIN}\) has no inaccessible states (remove any states not accessible from the start state)</li><li>\(M_{MIN}\) is irreducible: for all states \(p,q\neq p \in Q_{M_{MIN}}\), \(p \not \sim q\)</li></ul></li></ul><h3 id=steps>steps</h3><h4 id=remove-inaccessible-states>remove inaccessible states</h4><p>lol</p><h4 id=table-filling-algorithm>table-filling algorithm</h4><p>we now want to obtain all of our non distinguishable equivalent state classes.</p><p>Scratch-work:</p><p>States of \(M_{MIN}\) will be the equivalence classes of the states of \(M\); we cover these equivalence classes with a DP algorithm.</p><ul><li>Build a DP table: \(D_{M} =\qty {(p,q) | p,q \in Q, p \sim q}\).</li><li>Cluster them into equivalence classes: \(EQUIV_{M} = \qty {[q] | q \in Q}\)</li></ul><p>To build this table: we know how to find the pairs that \(\varepsilon\) distinguishes; then, we iterate to lengthen string length and find those pairs distinguishable with longer strings. The pairs of states then left over would be indistinguishable.</p><ul><li>base case: \((p,q)\) such that \(p\) accepts and \(q\) rejects, because they are distinguished by the empty string.</li><li>iteration: for each grid \(p,q\) and see if any symbol \(\sigma \in \Sigma\) satisfy&mdash;for \(\delta (p, \sigma) = p&rsquo;\), \(\delta (q, \sigma) = q&rsquo;\), we have \(p&rsquo; \not \sim q&rsquo;\); if that&rsquo;s the case, then \(p \not \sim q\)</li><li>we repeat until no more slots can be marked as non-distinguishable by going through an entire iteration without change</li></ul><p>Time complexity: \(O(|\Sigma| |q|^{2})\) (we go through each vocab item for each state). This algorithm iterates for at most \(q^{2}\) times.</p><p><strong>theorem</strong>: \(M_{MIN}\) is the unique minimal DFA that is equivalent to \(M\).</p><h4 id=define-our-new-dfa>define our new DFA</h4><p>\begin{equation}
M_{MIN} = \qty(Q_{MIN}, \Sigma, \delta_{MIN}, q_0_{MIN}, F_{MIN})
\end{equation}</p><p>we will define these vis a vi our new equivalence classes:</p><p>\begin{equation}
Q_{MIN} = EQU_{M}, q_{0}_{MIN} = \qty[q_0], F_{MIN} = \qty {[q] | q \in F}
\end{equation}</p><p>the transition function just needs to apply that of m on one member of your equivalence class:</p><p>\begin{equation}
\delta_{\min}\qty([q], \sigma) = \qty[\delta(q, \sigma)]
\end{equation}</p><p>this accepts the same language due to the definition of indistinguishable states (i.e. these equivalence classes).</p><h3 id=properties>properties</h3><ul><li>as a by product, this algorithm bounds the shortest distinguishing string between two <a href=#distinguishable-states>distinguishable states</a> by \(q^{2}\) because at each iteration of the algorithm it add at most one char to the end of the distinguishing string, and our system runs at most \(q^{2}\) times</li></ul><h3 id=proof-that-table-filling-algorithm--org01baaf4--works>proof that <a href=#table-filling-algorithm>table-filling algorithm</a> works</h3><h4 id=if--p-q--is-marked-then-p-not-sim-q-dot>if \((p,q)\) is marked, then \(p \not\sim q\).</h4><p>Proof:</p><p>We do induction. Invariant: whatever happened before is correct.</p><p>Base case: if \((p,q)\) is marked \(D\) at the start, then one state is in \(F\) and the other isn&rsquo;t, and so \(\varepsilon\) distinguishes \(p\) distinguishes \(q\).</p><p>Suppose \((p,q)\) is marked \(D\) at a later point, then there exists states \(p&rsquo;, q&rsquo;\) such that \(p&rsquo; \not \sim q&rsquo;\) and also \(p&rsquo; = \delta (p, \sigma )\) and \(q&rsquo; = \delta (q, \sigma)\).</p><p>Given \(p&rsquo; \not \sim q&rsquo;\), there&rsquo;s a string \(w\) such that \(\Delta(p&rsquo;, w) \in F \Leftrightarrow \Delta (q&rsquo;, w) \not \in F\); since we know there exists a symbol \(\sigma\) to get from \(p,q\) to \(p, q\), we can concatenate that to \(w\) like so (\(\sigma w\), processing our new symbol before the rest of the string) to show that \(\Delta(p, w) \in F \Leftrightarrow \Delta (q, w) \not \in F\), so \(p \not \sim q\).</p><h4 id=if--p-q--is-not-marked-then-p-sim-q-dot>if \((p,q)\) is <strong>not</strong> marked, then \(p \sim q\).</h4><p>Let&rsquo;s prove this by contradiction.</p><p>Suppose for contradiction the pair \((p,q)\) is not by \(D\), yet \(p \not \sim q\). Since \(p \not \sim q\), then there exists a string \(w\) such that \(|w| > 0\) (this is true because if \(w\) was the empty string it would fall into our base case already), \(\Delta(p, w) \in F \Leftrightarrow \Delta (q, w) \not \in F\).</p><p>If there are many such bad pairs, we choose the one with the <strong>shortest distinguishing string \(w\)</strong> that marks them.</p><p>Since \(w&rsquo;\) is non-empty, let&rsquo;s write \(w = \sigma w&rsquo;\). Let \(p&rsquo; = \delta (p, \sigma)\) and \(q&rsquo; = \delta(q, \sigma)\).</p><p>So, this means that \(p&rsquo; \not \sim q&rsquo;\) (because we just play the rest of \(w&rsquo;\) to distinguish them)&mdash;yet, they wouldn&rsquo;t have been marked because if they did our algorithm would have then marked \(p \not \sim q\) as well. This means that also \(p&rsquo;\) and \(q&rsquo;\) is also a bad pair.</p><p>Yet, we chose \(p, q\) to be the bad pair with the shortest distinguishing string; \(p&rsquo;, q&rsquo;\) have shorter distinguishing strings (namely, \(w&rsquo;\)). So, we reach contradiction.</p><h2 id=dfa-minimization-is-unique>DFA minimization is unique</h2><p><strong>theorem</strong>: \(M_{MIN}\) is the unique minimal DFA that is equivalent to \(M\).</p><h3 id=theorem-proof>theorem proof</h3><p>if \(M&rsquo;\) is a another minimal DFA for \(M\), then \(M&rsquo;\) has no inaccessible states and is irreducable; then, lemma 1 applies so there is an isomorphism between \(M&rsquo;\) and \(M_{MIN}\).</p><h3 id=lemma-1>lemma 1</h3><p>Lem. 1: Suppose there&rsquo;s some irreducible \(M&rsquo;\) where \(L(M&rsquo;) = L(M_{\min})\) with no inaccessible states; we have that there exist an <a href=/posts/kbhisomorphism/>isomorphism</a> between \(M&rsquo;\) and \(M_{\min}\).</p><p>Proof:</p><p>we need to construct such an <a href=/posts/kbhisomorphism/>isomorphism</a>.</p><ul><li>\(q_0_{\min} \to q_0&rsquo;\)</li><li>recursion:<ul><li>if \(p_{\min} \to p&rsquo;\) and \(\delta_{\min}(p_{\min}, \sigma) =q_{\min }\) and \(\delta&rsquo;(p&rsquo;, \sigma) =q&rsquo;\)</li><li>then we assign \(q_{\min } \to q&rsquo;\)</li></ul></li></ul><p>to show <a href=/posts/kbhisomorphism/>isomorphism</a></p><ul><li>defined everywhere</li><li>well defined</li><li>bijective</li><li>preserve all transitions (for all \(p \to p&rsquo;\), then \(\delta_{\min}(p, \sigma) \to \delta&rsquo;(p&rsquo;, \sigma)\)</li></ul><h4 id=defined-everywhere>defined everywhere</h4><p>for all states \(q\) of \(M_{\min }\), there exists \(q&rsquo;\) of \(m&rsquo;\) such that \(q \to q&rsquo;\)</p><p>if \(q \in M_{\min}\), then there is a string \(w\) such that \(\Delta_{\min}(q_0_{\min}, w) = q\). let \(q&rsquo; = \Delta&rsquo;(q&rsquo;_{0}, w)\), then \(q \to q&rsquo;\).</p><p>we show this by inducing the fact that we can define the mapping of these stages one at a time.</p><h4 id=one-to-one--injective>one-to-one (injective)</h4><p>we show this as a contradiction.</p><p>suppose by contradiction \(p \neq q\) such that \(p \to q&rsquo;\) and \(q \to q&rsquo;\); again, this means that we would (like in the well-defined case, but this time in \(M_{\min }\) now), tack on a string which sends us to accept and reject cases</p><figure><img src=/ox-hugo/2024-10-07_23-53-26_screenshot.png></figure><h4 id=surjective>surjective</h4><p>for all states \(q&rsquo;\) of \(M&rsquo;\), there exists a state \(q\) of \(M_{\min}\) such that \(q \to q&rsquo;\).</p><p>we can show this by noticing that for every state \(q&rsquo;\) in \(M&rsquo;\), we have some string \(w\) which \(M&rsquo;\) reaches to get there. we define \(q\) as the state of \(M_{\min}\) after applying \(w\). We claim \(q \to q&rsquo;\).</p><h4 id=well-defined>well-defined</h4><p>this needs to be a function, so we can&rsquo;t have cases where its \(q \to q&rsquo;\) yet also \(q \to q&rsquo;&rsquo;\) where \(q&rsquo; \neq q&rsquo;&rsquo;\).</p><p>suppose for contradiction \(q&rsquo;\) and \(q&rsquo;&rsquo;\) are distinguishable in \(M\)</p><figure><img src=/ox-hugo/2024-10-07_23-42-35_screenshot.png></figure><p>note that this is absurd because the same exact string \(w\) caused accept and reject by pulling back the map in \(M_{\min}\).</p></div></article></main><footer style=margin-top:20px><p id=footer style=font-size:8px;color:var(--gray-3)>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div><script src=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.32.2/tocbot.min.js></script><script>tocbot.init({tocSelector:"#toc",contentSelector:".center-clearfix",headingSelector:"h1, h2, h3",hasInnerContainers:!0})</script></body></html>