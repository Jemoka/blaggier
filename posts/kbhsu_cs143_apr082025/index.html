<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><meta name=viewport content="width=device-width,initial-scale=1"><script src=https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4></script><link rel=preconnect href=https://fonts.bunny.net><link href="https://fonts.bunny.net/css?family=ibm-plex-sans:300,400,400i,500,500i,600,700,700i" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>SU-CS143 APR082025</title>
<meta name=description content="Lexer
Goal: identify tokens in the input string. Its a lot of regular expressions and DFAing.
Example
Consider:
if (i == j)
    z = 0;
else
    z = 1;
We want a linear algorithm for lexing, because quadratic algorithms are slow. The gaol here is to partition the input string into substrings.
Let&rsquo;s make a Lexer!

identify token classes
describe which strings belong to each token

token classes
token classes define all items of interest; this is dependent on the choice of language and the design of the parser."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/all.css><link rel=stylesheet href=/css/page.css><link rel=stylesheet href=/css/syntax.css><link rel=stylesheet href=/css/typography.css><link rel=stylesheet href=/css/components.css></head><body><div class="center-clearfix p-10" style="max-width:1200px;margin:0 auto"><header class=pb-4><span class="w-full flex justify-between flex-wrap"><div style=font-weight:600;font-size:15px><a style=border:0;cursor:pointer href=/><img src=/images/Logo_Transparent.png style=width:17px;display:inline-block;margin-right:8px;transform:translateY(-2.7px)></a>SU-CS143 APR082025</div><span style="float:right;display:flex;align-items:center;margin-top:5px;width:100%;max-width:400px;background:#fff;border-radius:2px;border:1px solid var(--gray-2);position:relative"><i class="fa-solid fa-magnifying-glass" style=font-size:12px;color:var(--yellow-fg);margin-right:7px;margin-left:10px></i><div style=width:100%><input id=search-query-inline name=s type=text autocomplete=off placeholder="Search Knowledgebase" enterkeyhint=search></div><div id=search-result-inline style=display:none></div><script id=search-result-template type=text/x-js-template data-template=searchresult>
    <a href="${link}" class="search-link">
    <div class="search-result-item" id="search-result-item-${key}">
        <div class="search-result-title">${title}</div>
        <div class="search-result-summary">${snippet}</div>
    </div>
    </a>
</script><script src=https://code.jquery.com/jquery-3.3.1.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.0/fuse.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js></script><script type=module>
    import { create, insertMultiple, search } from 'https://cdn.jsdelivr.net/npm/@orama/orama@latest/+esm'
    let template = $('script[data-template="searchresult"]').text().split(/\$\{(.+?)\}/g);

    function render(props) {
        return function(tok, i) { return (i % 2) ? props[tok] : tok; };
    }

    const db = create({
        schema: {
            title: 'string',
            content: 'string',
        },
    });
    $.get("https://www.jemoka.com/index.json", function(data, status){
        insertMultiple(db, data.map(x =>
            ({title: x.title, content: x.contents, link: x.permalink})));
    });
    $("#search-result-inline").attr("tabindex", "-1");
    $(document).on("click", function (e) {
    if (!$(e.target).closest("#search-query-inline, #search-result-inline").length) {
        $("#search-result-inline").hide();
    }
    });
    
    
    
    
    
    

    $("#search-query-inline").on("focus keyup", function () {
        let value = $(this).val();
        if (value.trim() == "") {
            $("#search-result-inline").html("");
            $("#search-result-inline").hide();
            return;
        }
        $("#search-result-inline").show();
        let results = search(db, {mode: "fulltext", term: value});
        let contents = results.hits.map(x => template.map(render({
            title: x.document.title,
            snippet: x.document.content.slice(0, 52),
            key: x.id,
            link: x.document.link
        })).join(''));
        $("#search-result-inline").html(contents.join("\n"));
        
    });
    if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        $('#search-query-inline').on('focus', function(){
            
            $(this).data('fontSize', $(this).css('font-size')).css('font-size', '16px');
        }).on('blur', function(){
            
            $(this).css('font-size', $(this).data('fontSize'));
        });
    }

</script></span></span><div class=w-full style="padding-bottom:4px;border-bottom:1px solid var(--gray-1);margin-top:1px"></div></header><aside id=tocbox><div id=heading style=padding-left:40px;font-weight:600;font-size:11px;color:var(--gray-3)>contents</div><div id=toc></div></aside><main><article><div style=max-width:700px><h2 id=lexer>Lexer</h2><p>Goal: identify tokens in the input string. Its a lot of regular expressions and DFAing.</p><h3 id=example>Example</h3><p>Consider:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#111>i</span> <span style=color:#f92672>==</span> <span style=color:#111>j</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>z</span> <span style=color:#f92672>=</span> <span style=color:#111>0</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>else</span>
</span></span><span style=display:flex><span>    <span style=color:#111>z</span> <span style=color:#f92672>=</span> <span style=color:#111>1</span><span style=color:#111>;</span>
</span></span></code></pre></div><p>We want a <strong>linear</strong> algorithm for lexing, because quadratic algorithms are slow. The gaol here is to partition the input string into substrings.</p><h3 id=let-s-make-a-lexer>Let&rsquo;s make a Lexer!</h3><ol><li>identify <a href=#token-classes>token classes</a></li><li>describe which strings belong to each token</li></ol><h4 id=token-classes>token classes</h4><p><a href=#token-classes>token classes</a> define all items of interest; this is dependent on the choice of language and the design of the parser.</p><p>We separate the language into a few known tokens:</p><ul><li><p><strong>identifier</strong>: strings of letters or digits starting with a letter</p></li><li><p><strong>integer</strong>: non-empty string of digits</p></li><li><p><strong>keyword</strong>: else, if, begin, etc.</p></li><li><p><strong>whitespace</strong>: non-empty sequence of blanks, newlines, or tabs</p></li><li><p><strong>(</strong>: (</p></li><li><p><strong>[</strong>: [</p><p>etc.</p></li></ul><ul><li><p>a note on empty strings</p><p>Its very easy to write regexp which matches on empty strings, which will cause your lexer to spin forever because every position has infinite empty strings. So make sure you don&rsquo;t do that.</p></li></ul><h4 id=classifying-tokens>classifying tokens</h4><ol><li>clasify each substring as a token</li><li>return the value or lexeme of the token<ul><li><strong>lexeme</strong>: the actual substring</li><li><strong>token</strong>: the classified <a href=#token-classes>token class</a> which the substring belongs to</li></ul></li></ol><p>When we classify tokens, we want the &ldquo;<a href=#classifying-tokens>rule of maximum munch</a>&rdquo;:</p><h4 id=throwing-stuff-away>throwing stuff away</h4><p>We can just ignore 1) white spaces and 2) comments (what happens to <code>&lt;keyword> &lt;whitespace> &lt;keyword></code>? it just looks like <code>&lt;keyword> &lt;keyword></code> which is fine).</p><h3 id=can-this-be-hard>Can this be hard?</h3><p>Yes. Don&rsquo;t be FORTRAN: &ldquo;white space is insignificant&rdquo;. And then suddenly you can&rsquo;t tell the difference between:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span>      <span style=color:#00a8c8>DO</span> <span style=color:#ae81ff>5</span> <span style=color:#111>I</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#ae81ff>25</span>
</span></span></code></pre></div><p>versus</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span>      <span style=color:#00a8c8>DO</span> <span style=color:#ae81ff>5</span> <span style=color:#111>I</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.25</span>
</span></span></code></pre></div><p>where the latter is a variable named <code>DO5I</code> and the former is a do jump loop.</p><p>Or if you don&rsquo;t mix keywords and statements and now parsing takes forever.</p><h2 id=formalism>formalism</h2><h3 id=language>language</h3><p>see <a href=/posts/kbhalphabet/>language</a></p><h3 id=regular-languages>regular languages</h3><p>See <a href=/posts/kbhregular_language/>regular language</a>. For <a href=/posts/kbhregular_language/#properties-of-id-a8a2a1e4-9bb8-4a06-8218-5002136bab87-regular-language-s>properties of regular languages</a>, we take a recursive definition for regular \(A, B\) and alphabet \(\Sigma\):</p><p>the following is regular&mdash;</p><ul><li>empty string: \(L\qty(\epsilon) = \qty {&rsquo;&rsquo;}\)</li><li>member of the set: \(L\qty(&lsquo;c&rsquo;) = \qty {c}\) where our particular \(c \in \Sigma\)</li><li>union: \(L\qty(A + B) = \qty {w | w \in L(A)\ \cup\ w \in L(B) }\)</li><li>concatenation: \(L\qty(A B) = \{vw | v \in L(A), w \in L(B)\}\)</li><li>clean star: \(L(A^{*}) = \qty {s_1 \cdot \dots \cdot s_{k} | k \geq 0, s_{i} \in L(A)}\)</li></ul><h3 id=component>component</h3><ul><li>keywords: else = e+l+s+e, etc.</li><li>integers: digit = 0+1+2+&mldr;; integer = digit digit* = digit+</li><li>identifier: letter (letter + digit)*</li></ul></div></article></main><footer style=margin-top:20px><p id=footer style=font-size:8px;color:var(--gray-3)>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div><script src=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.32.2/tocbot.min.js></script><script>tocbot.init({tocSelector:"#toc",contentSelector:".center-clearfix",headingSelector:"h1, h2, h3",hasInnerContainers:!0})</script></body></html>