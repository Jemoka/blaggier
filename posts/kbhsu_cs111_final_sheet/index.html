<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><meta name=viewport content="width=device-width,initial-scale=1"><script src=https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4></script><link rel=preconnect href=https://fonts.bunny.net><link href="https://fonts.bunny.net/css?family=ibm-plex-sans:300,400,400i,500,500i,600,700,700i" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>SU-CS111 Final Sheet</title>
<meta name=description content="FS
main challenges

naming: how do users name files
reliability: surviving OS crashes and hardware failures
protection: isolation between users, controlled sharing
disk space management: minimize seeks, sharing space (&ldquo;preventing fragmentation&rdquo;)

seeks
to wait until the platter go under the arm and read.
internal v. external fragmentation

internal: a file can be no less than a single block of text.
external: no space is available even if the space in aggregate is available

main designs
contiguous allocation
IBM used this? puts files and meta-data together + implement an explicit free list allocator. benefit: simple; drawback: 1) external fragmentation 2) hard to grow files"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/all.css><link rel=stylesheet href=/css/page.css><link rel=stylesheet href=/css/syntax.css><link rel=stylesheet href=/css/typography.css><link rel=stylesheet href=/css/components.css></head><body><div class="center-clearfix p-10" style="max-width:1200px;margin:0 auto"><header class=pb-4><span class="w-full flex justify-between flex-wrap"><div style=font-weight:600;font-size:15px><a style=border:0;cursor:pointer href=/><img src=/images/Logo_Transparent.png style=width:17px;display:inline-block;margin-right:8px;transform:translateY(-2.7px)></a>SU-CS111 Final Sheet</div><span style="float:right;display:flex;align-items:center;margin-top:5px;width:100%;max-width:400px;background:#fff;border-radius:2px;border:1px solid var(--gray-2);position:relative"><i class="fa-solid fa-magnifying-glass" style=font-size:12px;color:var(--yellow-fg);margin-right:7px;margin-left:10px></i><div style=width:100%><input id=search-query-inline name=s type=text autocomplete=off placeholder="Search Knowledgebase" enterkeyhint=search></div><div id=search-result-inline style=display:none></div><script id=search-result-template type=text/x-js-template data-template=searchresult>
    <a href="${link}" class="search-link">
    <div class="search-result-item" id="search-result-item-${key}">
        <div class="search-result-title">${title}</div>
        <div class="search-result-summary">${snippet}</div>
    </div>
    </a>
</script><script src=https://code.jquery.com/jquery-3.3.1.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.0/fuse.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js></script><script type=module>
    import { create, insertMultiple, search } from 'https://cdn.jsdelivr.net/npm/@orama/orama@latest/+esm'
    let template = $('script[data-template="searchresult"]').text().split(/\$\{(.+?)\}/g);

    function render(props) {
        return function(tok, i) { return (i % 2) ? props[tok] : tok; };
    }

    const db = create({
        schema: {
            title: 'string',
            content: 'string',
        },
    });
    $.get("https://www.jemoka.com/index.json", function(data, status){
        insertMultiple(db, data.map(x =>
            ({title: x.title, content: x.contents, link: x.permalink})));
    });
    $("#search-result-inline").attr("tabindex", "-1");
    $(document).on("click", function (e) {
    if (!$(e.target).closest("#search-query-inline, #search-result-inline").length) {
        $("#search-result-inline").hide();
    }
    });
    
    
    
    
    
    

    $("#search-query-inline").on("focus keyup", function () {
        let value = $(this).val();
        if (value.trim() == "") {
            $("#search-result-inline").html("");
            $("#search-result-inline").hide();
            return;
        }
        $("#search-result-inline").show();
        let results = search(db, {mode: "fulltext", term: value});
        let contents = results.hits.map(x => template.map(render({
            title: x.document.title,
            snippet: x.document.content.slice(0, 52),
            key: x.id,
            link: x.document.link
        })).join(''));
        $("#search-result-inline").html(contents.join("\n"));
        
    });
    if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        $('#search-query-inline').on('focus', function(){
            
            $(this).data('fontSize', $(this).css('font-size')).css('font-size', '16px');
        }).on('blur', function(){
            
            $(this).css('font-size', $(this).data('fontSize'));
        });
    }

</script></span></span><div class=w-full style="padding-bottom:4px;border-bottom:1px solid var(--gray-1);margin-top:1px"></div></header><aside id=tocbox><div id=heading style=padding-left:40px;font-weight:600;font-size:11px;color:var(--gray-3)>contents</div><div id=toc></div></aside><main><article><div style=max-width:700px><h2 id=fs>FS</h2><h3 id=main-challenges>main challenges</h3><ul><li><strong>naming</strong>: how do users name files</li><li><strong>reliability</strong>: surviving OS crashes and hardware failures</li><li><strong>protection</strong>: isolation between users, controlled sharing</li><li><strong>disk space management</strong>: minimize seeks, sharing space (&ldquo;preventing fragmentation&rdquo;)</li></ul><h4 id=seeks>seeks</h4><p>to wait until the platter go under the arm and read.</p><h4 id=internal-v-dot-external-fragmentation>internal v. external fragmentation</h4><ul><li><strong>internal</strong>: a file can be no less than a single block of text.</li><li><strong>external</strong>: no space is available even if the space in aggregate is available</li></ul><h3 id=main-designs>main designs</h3><h4 id=contiguous-allocation>contiguous allocation</h4><p>IBM used this? puts files and meta-data together + implement an explicit free list allocator. <strong>benefit</strong>: simple; <strong>drawback</strong>: 1) external fragmentation 2) hard to grow files</p><h4 id=linked-files>linked files</h4><p>in every block, store the location of the next block; don&rsquo;t store files continuously&mdash;instead, store a pointer to where the next block of the file is. <strong>benefit</strong>: solves fragmentation and file growth; <strong>drawback</strong>: 1) huge seek time 2) random access from the middle is hard (i.e. O(n))</p><h4 id=windows-fat>Windows FAT</h4><p>linked files, but cached the file links in memory when using it. <strong>benefits</strong>: same as linked files, and a bit faster <strong>drawback</strong>: data <em>still</em> fragmented and now you have a whole ass table to deal with! but its at least faster</p><h4 id=file-payload-data>File Payload Data</h4><p>Kind of what we do&mdash;instead of storing file data in order OR using links, store the file BLOCK information contiguously.</p><p><em>multi-level index</em>: store all block numbers for a given file down a tree (EXT2/3, Unix V6, NTFS)</p><h3 id=unix-v6-plus-mli>Unix V6 + MLI</h3><table><thead><tr><th>Sector Size</th><th>Block Size</th><th>Inode Size</th><th>Inodes Per Block</th><th>Address Type</th></tr></thead><tbody><tr><td>512</td><td>512</td><td>32</td><td>16</td><td>Short, 2 bytes</td></tr></tbody></table><h4 id=block>block</h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#00a8c8>const</span> <span style=color:#00a8c8>size_t</span> <span style=color:#111>INODE_PER_BLOCK</span> <span style=color:#f92672>=</span> <span style=color:#111>SECTOR_SIZE</span> <span style=color:#f92672>/</span> <span style=color:#00a8c8>sizeof</span><span style=color:#111>(</span><span style=color:#00a8c8>struct</span> <span style=color:#111>inode</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>struct</span> <span style=color:#111>inode</span> <span style=color:#111>inodes</span><span style=color:#111>[</span><span style=color:#111>INODE_PER_BLOCK</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>char</span> <span style=color:#111>buf</span><span style=color:#111>[</span><span style=color:#111>SECTOR_SIZE</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span><span style=color:#75af00>readsector</span><span style=color:#111>(</span><span style=color:#ae81ff>2</span><span style=color:#111>,</span> <span style=color:#f92672>&amp;</span><span style=color:#111>inodes</span><span style=color:#111>);</span> <span style=color:#75715e>// recall this is the first 16 inodes: sec0 is fs info, sec1 is supernode
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75af00>printf</span><span style=color:#111>(</span><span style=color:#d88200>&#34;addr: %d</span><span style=color:#8045ff>\n</span><span style=color:#d88200>&#34;</span><span style=color:#111>,</span> <span style=color:#111>inodes</span><span style=color:#111>[</span><span style=color:#ae81ff>0</span><span style=color:#111>].</span><span style=color:#111>i_add</span><span style=color:#111>);</span>
</span></span></code></pre></div><h4 id=ino>ino</h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#00a8c8>struct</span> <span style=color:#111>inode</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>uint16_t</span> <span style=color:#111>i_addr</span><span style=color:#111>[</span><span style=color:#ae81ff>8</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>uint16_t</span> <span style=color:#111>i_mode</span><span style=color:#111>[</span><span style=color:#ae81ff>8</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>uint16_t</span> <span style=color:#111>file_size</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><p><a href=/posts/kbhunix_v6_filesystem/>inode</a>s have two modes</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#00a8c8>if</span> <span style=color:#111>((</span><span style=color:#111>inode</span><span style=color:#111>.</span><span style=color:#111>i_mode</span> <span style=color:#f92672>&amp;</span> <span style=color:#111>ILARG</span><span style=color:#111>)</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span><span style=color:#111>)</span> <span style=color:#f92672>==</span> <span style=color:#75715e>// node is in &#34;large mode&#34;
</span></span></span></code></pre></div><ul><li>in <strong>small mode</strong>, the <a href=/posts/kbhunix_v6_filesystem/>inode</a> stores in <code>i_addr</code> the block numbers to the data</li><li>in <strong>large mode</strong>, the <a href=/posts/kbhunix_v6_filesystem/>inode</a> stores in the <strong>first seven</strong> numbers in <code>i_addr</code> block numbers to <em>blocks that contain block numbers</em> (512/2 = 256 block numbers, which are chars); the <strong>eighth number</strong> points to <strong>doubly indirect</strong> <em>blocks that contain block numbers that point to other blocks</em></li></ul><p>The <a href=/posts/kbhunix_v6_filesystem/>inode</a> table for each file only contains space to point to \(8\) block. 1 block = 1 sector on Unix v6. <a href=/posts/kbhunix_v6_filesystem/>inode</a>s are usualy 32 bytes big, and 1 block = 1 sector = 512 bytes. usually this packs 16 inodes per block</p><p>in <strong>large mode</strong>, this system can store \((7+256) \cdot (256 \cdot 512) = 34MB\), which is as large as the file system itself, which means we are fine now.</p><ul><li><p>sizing</p><ul><li>small: \(512\) bytes per block, and \(8\) block storable, so \(8 \cdot 512 = 4096\) bytes</li><li>large: \(512\) bytes per block pointed to by i_addr, each containing \(\frac{512}{2} = 256\) block numbers. The first seven in total would therefore address \(256 \times 7 = 1792\) blocks of memory. The last eight would each address \(256 \cdot 256 = 65536\) blocks of memory. In total, that addresses \(1792+65536 = 67328\) blocks of memory. Finally, that means we can address \(67328 \cdot 512 = 34471936\) bytes.</li></ul></li></ul><h4 id=dir>dir</h4><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#00a8c8>struct</span> <span style=color:#111>dirent</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>uint16_t</span> <span style=color:#111>d_inumber</span><span style=color:#111>;</span> <span style=color:#75715e>// inode number of this file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>char</span> <span style=color:#111>d_name</span><span style=color:#111>[</span><span style=color:#ae81ff>14</span><span style=color:#111>];</span> <span style=color:#75715e>// the name; *NOT NECESSARILY NULL TERMINATED*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#111>}</span>
</span></span></code></pre></div><p><strong>THE NAME MAY NOT BE NULL TERMINATED</strong> to cram max things. You have to use <strong>strncmp</strong></p><p><strong>strcmp/strncmp</strong>: stops comparing after \(n\) characters; &lt;0 if str1 comes before str2 alphabetically; >0 if str1 comes after str2; 0 if equal</p><p>Start at the root directory, <code>/</code>. We want to go to the root directory, and find the entry named <code>/classes/</code>, and then, in that directory, find the file. etc. Traverse recursively. Directory could have metadata.</p><p>A directory is basically just a <strong>file whose payload is a list of <code>dirent</code></strong>.</p><p>The inode tells you whether something is a file or a directory. They can be small or large, as usual. Root directory always have inode number <code>1</code>; <code>0</code> is reserved to NULL.</p><h4 id=file>file</h4><p>Recall that <code>read</code> doesn&rsquo;t read the whole thing. So, we it in parts.</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#00a8c8>void</span> <span style=color:#75af00>copyContents</span><span style=color:#111>(</span><span style=color:#00a8c8>int</span> <span style=color:#111>sourceFD</span><span style=color:#111>,</span> <span style=color:#00a8c8>int</span> <span style=color:#111>destinationFD</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>char</span> <span style=color:#111>buffer</span><span style=color:#111>[</span><span style=color:#111>INCREMENT</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>while</span> <span style=color:#111>(</span><span style=color:#111>true</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#111>ssize_t</span> <span style=color:#111>bytesRead</span> <span style=color:#f92672>=</span> <span style=color:#111>read</span><span style=color:#111>(</span><span style=color:#111>sourceFD</span><span style=color:#111>,</span> <span style=color:#111>buffer</span><span style=color:#111>,</span> <span style=color:#00a8c8>sizeof</span><span style=color:#111>(</span><span style=color:#111>buffer</span><span style=color:#111>));</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#111>bytesRead</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#111>)</span> <span style=color:#00a8c8>break</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>size_t</span> <span style=color:#111>bytesWritten</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>while</span> <span style=color:#111>(</span><span style=color:#111>bytesWritten</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>bytesRead</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>            <span style=color:#111>ssize_t</span> <span style=color:#111>count</span> <span style=color:#f92672>=</span> <span style=color:#111>write</span><span style=color:#111>(</span><span style=color:#111>destinationFD</span><span style=color:#111>,</span> <span style=color:#111>buffer</span> <span style=color:#f92672>+</span> <span style=color:#111>bytesWritten</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>                                  <span style=color:#111>bytesRead</span> <span style=color:#f92672>-</span> <span style=color:#111>bytesWritten</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>            <span style=color:#111>bytesWritten</span> <span style=color:#f92672>+=</span> <span style=color:#111>count</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>}</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#00a8c8>int</span> <span style=color:#75af00>open</span><span style=color:#111>(</span><span style=color:#00a8c8>const</span> <span style=color:#00a8c8>char</span> <span style=color:#f92672>*</span><span style=color:#111>pathname</span><span style=color:#111>,</span> <span style=color:#00a8c8>int</span> <span style=color:#111>flags</span><span style=color:#111>);</span>
</span></span></code></pre></div><p>Flags are a bitwise OR operations: you have to open with <code>O_RDONLY</code> (read only), <code>O_WRONLY</code> (write only), or <code>O_RDWR</code> (both read and write). This returns \(-1\) if the reading fails.</p><p>Other flags:</p><ul><li><code>O_TRUNC</code> (truncate file)</li><li><code>O_CREAT</code> (creating a file if not exist), which will require a <code>mode_t mode</code> parameter to set the permission</li><li><code>O_EXCL</code> (file must not exist)</li></ul><h4 id=open-file-table>open file table</h4><p>open-file table is <strong>system wide</strong>: mentioning what mode an opening is + the cursor to the open file + the number of file-descriptors pointing to it to a <code>refcount</code>.</p><p>why is <code>refcount</code> ever higher than 1? because forks.</p><h3 id=block-cache>Block Cache</h3><p>We will use part of the main memory to retain recently-accessed disk <strong>blocks</strong>. This is <strong>NOT</strong> at the granularity of individual files.</p><h4 id=least-recently-used--lru--cache>Least Recently Used (LRU) Cache</h4><p>When you insert a new element into the cache, kick out the element on the cache that hasn&rsquo;t been touched in the longest time.</p><h4 id=block-cache-modification>Block Cache Modification</h4><p>we can either <strong>write asap</strong>, or <strong>delay</strong>.</p><p><strong><strong>write asap</strong></strong>: <em>safer</em>: less risk of data loss, written as soon as possible; <em>slow</em>: program must wait to proceed until disk I/O completes</p><p><strong><strong>write delay</strong></strong>: <em>dangerous</em>: may loose data after crash; <em>efficient</em>: memory writes is faster</p><h2 id=crash-recovery>Crash Recovery</h2><h3 id=main-challenges>main challenges</h3><ul><li><strong>data loss</strong>: crashes can happen, and not all data could be saved to disk</li><li><strong>inconsistency</strong>: crashes can happen in the middle of operations</li></ul><p>Ideally, filesystem operations should be <strong>atomic</strong>. Every operation should happen or not happen at all&mdash;but not halfway.</p><h3 id=fsck>fsck</h3><ul><li>Check whether or not there is a clean shutdown: setting a disk flag on clean shutdown; so if the flag isn&rsquo;t set there isn&rsquo;t a clean shutdown.</li><li>If it wasn&rsquo;t a clean shutdown, identify inconsistencies</li><li>Scans meta data (inodes, indirect blocks, free list, directory blocks) and handle any of the following situations&mdash;<ol><li>block in an inode and in free list; solution: pull the block off of free list</li><li>block is a part of two inodes; solution: give to newest, random, copy, remove (bad idea)</li><li>inode claims one dirent refers to it, but there are no such dirent; solution: put in lost and found</li></ol></li></ul><h4 id=limitations>limitations</h4><ul><li>takes long because can&rsquo;t restart until done</li><li>doesn&rsquo;t prevent loss of actual file info</li><li>filesystem may still be unusable (core files moved to lost+found)</li><li>a block could migrate during recovery, leaking info</li></ul><h3 id=ordered-writes>ordered writes</h3><ol><li>Always initialize the <strong>TARGET</strong> before initializing the <strong>REFERENCE</strong><ul><li>Initialize inode before initalize directory entry to it</li></ul></li><li>Never reuse a resource before <strong>NULLIFYING</strong> all existing <strong><strong>REFERENCES</strong></strong><ul><li>Remove the inode reference before putting a block on the free list</li></ul></li><li>Never clear the <strong><strong>LAST REFERENCE</strong></strong> to a live resource before setting a <strong><strong>NEW REFERENCE</strong></strong> (&ldquo;its better to have 2 copies instead of none&rdquo;)<ul><li>Make the new directory entry before get rid of the old one</li></ul></li></ol><h4 id=limitations>limitations</h4><ul><li><strong>performance</strong>: we need to do operations synchronously<ul><li>if we really want to do caching async, we can track dependencies</li><li>circular dependencies are possible</li></ul></li><li><strong><strong>leak</strong></strong>: it could leak resources (reference nullification happens but resource not added)<ul><li>We can run fsck in the background</li></ul></li></ul><h3 id=journaling>journaling</h3><p><a href=/posts/kbhcrash_recovery/#journaling>journaling</a> keeps a paper trail of disk appertains in the event of a crash. We have an append-only log on disk that stores disk operations.</p><ul><li>before performing an operation, record its info in the log</li><li>and write that to disk</li></ul><p>The log will always record what&rsquo;s happening ahead. The actual block updates can eventually be carried out in any order.</p><h4 id=what-do-we-log>what do we log?</h4><ul><li>we only log <strong>metadata</strong> changes (inodes, moving stuff around, etc.)</li><li>payload operations are not saved</li></ul><h4 id=structure>structure</h4><p>We typically have a LSN: log serial number, operations, and metadata.</p><ul><li><strong>LogPatch</strong>: changes something</li><li><strong>LogBlockFree</strong>: mark something as free</li><li><strong>LogBlockAlloc</strong>: mark something as allocated, optionally zeroing data if its a data block (DO NOT zero if its a dirent or ino)</li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span><span style=color:#111>[</span><span style=color:#75af00>offset</span> <span style=color:#ae81ff>335050</span><span style=color:#111>]</span>
</span></span><span style=display:flex><span><span style=color:#75af00>LSN</span> <span style=color:#ae81ff>18384030</span>
</span></span><span style=display:flex><span><span style=color:#75af00>operation</span> <span style=color:#111>=</span> <span style=color:#d88200>&#34;LogBlockAlloc&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75af00>blockno</span> <span style=color:#111>=</span> <span style=color:#ae81ff>1027</span>
</span></span><span style=display:flex><span><span style=color:#75af00>zero_on_replay</span> <span style=color:#111>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#111>[</span><span style=color:#75af00>offset</span> <span style=color:#ae81ff>23232</span><span style=color:#111>]</span>
</span></span><span style=display:flex><span><span style=color:#75af00>LSN</span> <span style=color:#75af00>N</span>
</span></span><span style=display:flex><span><span style=color:#75af00>operation</span> <span style=color:#111>=</span> <span style=color:#d88200>&#34;LogPatch&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75af00>blockno</span> <span style=color:#111>=</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span><span style=color:#75af00>offset</span> <span style=color:#111>=</span> <span style=color:#ae81ff>137</span>
</span></span><span style=display:flex><span><span style=color:#75af00>bytes</span> <span style=color:#111>=</span> <span style=color:#ae81ff>0.04</span>
</span></span><span style=display:flex><span><span style=color:#75af00>inode</span> <span style=color:#111>=</span> <span style=color:#ae81ff>52</span>
</span></span></code></pre></div><h4 id=limitations-and-fixes>limitations and fixes</h4><ul><li><strong>multiple log entries</strong>: each atomic operation will be wrapped into a unit <strong>transaction</strong> to make <strong>idempotent</strong></li><li><strong>checkpoints</strong>: we can truncate the log occasionally at a <strong>checkpoint</strong>&mdash;when it is no longer needed</li><li><strong>where do we start replaying</strong>: log entries should be <strong>idempotent</strong>&mdash;doing something multiple times should have the same effect of doing them once. Logs cannot have external dependencies</li><li><strong>log entries may take time</strong>: when finally we write stuff to disk, we write the logs first. So no problems there.</li></ul><h4 id=tradeoffs>tradeoffs</h4><ul><li><strong>durability</strong> - the data needs to be safe (which is slow, and may require manual crash recovery (sans cache, etc.))</li><li><strong>performance</strong> - it needs to be fast (which may mean less error checking)</li><li><strong>consistency</strong> - the filesystem needs to be uniform (which means that we need to be slower and we may drop data in favor of previous checkpoints that worked)</li></ul><h2 id=mp>MP</h2><p>Multiprocessing: processes, PIDs, fork, execution order, copy on write, waitpid, zombie processes, execvp, pipes and pipe / pipe2, I/O redirection</p><h3 id=forking>forking</h3><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#111>pid_t</span> <span style=color:#111>child_pid</span> <span style=color:#f92672>=</span> <span style=color:#111>fork</span><span style=color:#111>();</span>
</span></span></code></pre></div><p>fork returns the child PID if parent; returns 0 if child.</p><p>The arguments list have to <strong>BEGIN WITH EXECUTABLE NAME</strong> and <strong>END WITH NULL</strong>.</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#00a8c8>char</span> <span style=color:#f92672>*</span><span style=color:#111>args</span><span style=color:#111>[]</span> <span style=color:#f92672>=</span> <span style=color:#111>{</span> <span style=color:#d88200>&#34;/bin/ls&#34;</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;-l&#34;</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;~/hewo&#34;</span><span style=color:#111>,</span> <span style=color:#111>NULL</span> <span style=color:#111>};</span>
</span></span><span style=display:flex><span><span style=color:#75af00>execvp</span><span style=color:#111>(</span><span style=color:#111>args</span><span style=color:#111>[</span><span style=color:#ae81ff>0</span><span style=color:#111>],</span> <span style=color:#111>args</span><span style=color:#111>);</span>
</span></span></code></pre></div><p><strong>execvp LEAVES THE FILE DESCRIPTOR TABLE</strong>.</p><p>every fork has to be waited on by <code>waitpid</code>:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#00a8c8>pid_t</span> <span style=color:#75af00>waitpid</span><span style=color:#111>(</span><span style=color:#00a8c8>pid_t</span> <span style=color:#111>pid</span><span style=color:#111>,</span> <span style=color:#00a8c8>int</span> <span style=color:#f92672>*</span><span style=color:#111>status</span><span style=color:#111>,</span> <span style=color:#00a8c8>int</span> <span style=color:#111>options</span><span style=color:#111>);</span>
</span></span></code></pre></div><ul><li>pid</li><li>status: pointer to store return about the child</li><li>options (0 for now)</li></ul><p>if the PID has died, this returns immediately. Otherwise, this blocks.</p><h4 id=the-status-int>the <code>status</code> int</h4><p>is a bitmap with a bunch of stuff, which we can check with a series of macros</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#00a8c8>int</span> <span style=color:#111>status</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>int</span> <span style=color:#111>pid_act</span> <span style=color:#f92672>=</span> <span style=color:#75af00>waitpid</span><span style=color:#111>(</span><span style=color:#111>pid</span><span style=color:#111>,</span> <span style=color:#f92672>&amp;</span><span style=color:#111>status</span><span style=color:#111>,</span> <span style=color:#ae81ff>0</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#75af00>WIFEXISTED</span><span style=color:#111>(</span><span style=color:#111>status</span><span style=color:#111>))</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// child normal exit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>int</span> <span style=color:#111>statuscode</span> <span style=color:#f92672>=</span> <span style=color:#75af00>WEXITSTATUS</span><span style=color:#111>(</span><span style=color:#111>status</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span> <span style=color:#00a8c8>else</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// abnormal exist
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#111>}</span>
</span></span></code></pre></div><p>the returned PID is the PID that got waited on; if the input PID is <code>-1</code>, it will wayt on any process</p><h4 id=fork-mechanics>fork mechanics</h4><p>The act of copying stack and heap sounds really really expensive. So&mldr;. Whapppens?</p><p>The child will map the parent&rsquo;s memory addresses to <strong>different</strong> physical addresses than for the parent. The copies are <strong>LAZY</strong>&mdash;if the child writes to an area in memory, its virtual address are mapped to different addresses. If no writes by the child happen, the virtual address are mapped to the same address.</p><p>during file reading, the file descriptors gets cloned, the underlying <a href=/posts/kbhmultiprocessing/#open-file-table>open file table</a> doesn&rsquo;t close.</p><h3 id=pipes>pipes</h3><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#00a8c8>int</span> <span style=color:#111>pipes</span><span style=color:#111>[</span><span style=color:#ae81ff>2</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// create the pipes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#00a8c8>int</span> <span style=color:#111>ret</span> <span style=color:#f92672>=</span> <span style=color:#75af00>pipe</span><span style=color:#111>(</span><span style=color:#111>pipes</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* int ret = pipe2(pipes, O_CLOEXEC); */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// an so
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#00a8c8>int</span> <span style=color:#111>read_from_here</span> <span style=color:#f92672>=</span> <span style=color:#111>ret</span><span style=color:#111>[</span><span style=color:#ae81ff>0</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>int</span> <span style=color:#111>write_to_here</span> <span style=color:#f92672>=</span> <span style=color:#111>ret</span><span style=color:#111>[</span><span style=color:#ae81ff>1</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// i.e. ret[1] writes to =&gt; ret[0] read
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// fork!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#00a8c8>pid_t</span> <span style=color:#111>pid_p</span> <span style=color:#f92672>=</span> <span style=color:#75af00>fork</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>if</span><span style=color:#111>(</span><span style=color:#111>pid_p</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// child subroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// because child is READING, and not READINg
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// we want to close the write
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75af00>close</span><span style=color:#111>(</span><span style=color:#111>write_to_here</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// we want to then make a buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>char</span> <span style=color:#111>buf</span><span style=color:#111>[</span><span style=color:#111>num_bytes</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// if the child reads before the parents write
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// it will block until some data is available
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// if the write ends are closed globally, read
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// will also stop.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75af00>read</span><span style=color:#111>(</span><span style=color:#111>read_from_here</span><span style=color:#111>,</span> <span style=color:#111>buffer</span><span style=color:#111>,</span> <span style=color:#00a8c8>sizeof</span><span style=color:#111>(</span><span style=color:#111>buffer</span><span style=color:#111>));</span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>close</span><span style=color:#111>(</span><span style=color:#111>read_from_here</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// parent subroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e>// because parent is WRITING and not READING
</span></span></span><span style=display:flex><span><span style=color:#75715e>// we don&#39;t want the read to block, we will
</span></span></span><span style=display:flex><span><span style=color:#75715e>// close the parent immediately.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75af00>close</span><span style=color:#111>(</span><span style=color:#111>read_from_here</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// write some data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75af00>write</span><span style=color:#111>(</span><span style=color:#111>write_to_here</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;msg&#34;</span><span style=color:#111>,</span> <span style=color:#111>num_bytes</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// close now we are done writing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75af00>close</span><span style=color:#111>(</span><span style=color:#111>write_to_here</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// clean up child
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75af00>waitpid</span><span style=color:#111>(</span><span style=color:#111>pid_p</span><span style=color:#111>,</span> <span style=color:#111>NULL</span><span style=color:#111>,</span> <span style=color:#ae81ff>0</span><span style=color:#111>);</span>
</span></span></code></pre></div><p>Recall that dup2 exists:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#111>dup2</span><span style=color:#111>(</span><span style=color:#111>fds</span><span style=color:#111>[</span><span style=color:#ae81ff>0</span><span style=color:#111>],</span> <span style=color:#111>STDIN_FILENO</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span><span style=color:#111>close</span><span style=color:#111>(</span><span style=color:#111>fds</span><span style=color:#111>[</span><span style=color:#ae81ff>0</span><span style=color:#111>]);</span>
</span></span></code></pre></div><p>it will close the second file descriptor, if already in use, before binding the first file descriptor to it.</p><h3 id=shell>shell</h3><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#00a8c8>while</span> <span style=color:#111>(</span><span style=color:#111>true</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>char</span> <span style=color:#f92672>*</span><span style=color:#111>command</span> <span style=color:#f92672>=</span> <span style=color:#111>{</span> <span style=color:#d88200>&#34;ls&#34;</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;things&#34;</span> <span style=color:#111>};</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#111>pid_t</span> <span style=color:#111>child_pid</span> <span style=color:#f92672>=</span> <span style=color:#111>fork</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#f92672>!</span><span style=color:#111>child_pid</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// this is the child; execvp will check PATH for you
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#111>execvp</span><span style=color:#111>(</span><span style=color:#111>command</span><span style=color:#111>.</span><span style=color:#111>argv</span><span style=color:#111>[</span><span style=color:#ae81ff>0</span><span style=color:#111>],</span> <span style=color:#111>command</span><span style=color:#111>.</span><span style=color:#111>argv</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if we got here, the PID didn&#39;t do well
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#00a8c8>throw</span> <span style=color:#75af00>STSHException</span><span style=color:#111>(</span><span style=color:#111>string</span><span style=color:#111>(</span><span style=color:#111>command</span><span style=color:#111>.</span><span style=color:#111>argv</span><span style=color:#111>[</span><span style=color:#ae81ff>0</span><span style=color:#111>])</span><span style=color:#f92672>+</span><span style=color:#d88200>&#34;: not found or didn&#39;t succeed to fork.&#34;</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#111>waitpid</span><span style=color:#111>(</span><span style=color:#111>child_pid</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// do cleanup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#111>}</span>
</span></span></code></pre></div><h2 id=mt>MT</h2><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// now the thread can execute at any time: once a thread is made, it will run in any order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#00a8c8>thread</span> <span style=color:#75af00>myThread</span><span style=color:#111>(</span><span style=color:#111>function_to_run</span><span style=color:#111>,</span> <span style=color:#111>arg1</span><span style=color:#111>,</span> <span style=color:#111>arg2</span><span style=color:#111>,</span> <span style=color:#111>...);</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// threads run AS SOON AS SPAWENED: so
</span></span></span></code></pre></div><p>We can wait for a thread:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#111>myThread</span><span style=color:#111>.</span><span style=color:#111>join</span><span style=color:#111>()</span>
</span></span></code></pre></div><p>You can also start a bunch on a loop:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#00a8c8>thread</span> <span style=color:#111>threads</span><span style=color:#111>[</span><span style=color:#ae81ff>3</span><span style=color:#111>];</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#00a8c8>thread</span><span style=color:#f92672>&amp;</span> <span style=color:#111>cf</span> <span style=color:#111>:</span> <span style=color:#111>threads</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#111>cf</span> <span style=color:#f92672>=</span> <span style=color:#00a8c8>thread</span><span style=color:#111>(</span><span style=color:#111>func</span><span style=color:#111>,</span> <span style=color:#111>...);</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><h3 id=passing-by-reference>passing by reference</h3><p>threading doesn&rsquo;t know the type of arguments being passed into a function; this is especially prevalent when passing by reference.</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#00a8c8>static</span> <span style=color:#00a8c8>void</span> <span style=color:#75af00>mythingref</span><span style=color:#111>(</span><span style=color:#00a8c8>int</span> <span style=color:#f92672>&amp;</span><span style=color:#111>pbr</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>thread</span><span style=color:#111>(</span><span style=color:#111>myfunc</span><span style=color:#111>,</span> <span style=color:#111>ref</span><span style=color:#111>(</span><span style=color:#111>myint</span><span style=color:#111>));</span>
</span></span></code></pre></div><p>Remember: ref will <strong><strong>SHARE MEMORY</strong></strong>, and you have no control over when the thread runs. So once a pointer is passed all bets are off in terms of what values things take on.</p><h3 id=mutex>mutex</h3><p>it would be nice if a <a href=/posts/kbhmultithreading/#critical-section>critical section</a> can only be executed once; a <a href=/posts/kbhmultithreading/#mutex>mutex</a> can be shared across threads, but can only be &ldquo;owned&rdquo; by a single thread at once.</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#111>mutex</span> <span style=color:#111>tmp</span><span style=color:#111>;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#111>tmp</span><span style=color:#111>.</span><span style=color:#111>lock</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span><span style=color:#111>tmp</span><span style=color:#111>.</span><span style=color:#111>unlock</span><span style=color:#111>();</span>
</span></span></code></pre></div><p>importantly, if multiple <a href=/posts/kbhmultithreading/#thread>thread</a>s are waiting on a mutex, the next thread that&rsquo;s going to get the mutex</p><ul><li>when there are multiple threads <strong>writing</strong> to a value</li><li>when there is a thread <strong>writing</strong> and one or more threads <strong>reading</strong></li><li>if you are no writes, you don&rsquo;t need a mutex<div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#00a8c8>int</span> <span style=color:#111>locked</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span><span style=color:#111>Queue</span> <span style=color:#111>blocked_queue</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>void</span> <span style=color:#111>Lock</span><span style=color:#f92672>::</span><span style=color:#111>Lock</span><span style=color:#111>()</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// disable interrupts: otherwise multiple threads
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// could come and lock the mutex (such as between
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// the locked check and lock =1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>IntrGuard</span> <span style=color:#111>grd</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#f92672>!</span><span style=color:#111>locked</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if our thread is not locked, just lock it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#111>locked</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span> <span style=color:#00a8c8>else</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if our thread is locked, we need to prevent our current
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// thread from going to the ready queue, and push it to the current thread
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#111>blocked_queue</span><span style=color:#111>.</span><span style=color:#111>push</span><span style=color:#111>(</span><span style=color:#111>CURRENT_THREAD</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// remember this isn&#39;t an issue even if IntrGuard
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// didn&#39;t yet go out of scope; because it will either
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// land on a context_switch which will enable interrupts for you
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// or land on the beginning of a threadfunc helper, which
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// is also going to enable interrupts for you
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// nicely, the interrupts are here are *off* as required because switching
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// to another thread always will result in reenabling (either by new thread,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// by timer handler, or by IntrGuard)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#111>mark_block_and_call_schedule</span><span style=color:#111>(</span><span style=color:#111>CURRENT_THREAD</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>void</span> <span style=color:#111>Lock</span><span style=color:#f92672>::</span><span style=color:#111>Unlock</span><span style=color:#111>()</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// disable interrupts: otherwise multiple threads
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// could come and lock the mutex (such as between
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// the locked check and lock =1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>IntrGuard</span> <span style=color:#111>grd</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// if our thread is locked and nobody is waiting for it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#111>q</span><span style=color:#111>.</span><span style=color:#111>empty</span><span style=color:#111>())</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#111>locked</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span> <span style=color:#00a8c8>else</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#111>unblock_thread</span><span style=color:#111>(</span><span style=color:#111>q</span><span style=color:#111>.</span><span style=color:#111>pop</span><span style=color:#111>());</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// we do not switch to the unblocked thread, just add it to the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// ready queue. we are entrusting the scheduler to start this thread
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// whenever we feel right
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div></li></ul><h3 id=cv>CV</h3><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#111>condition_variable_any</span> <span style=color:#111>permitsCV</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>thread</span><span style=color:#111>(</span><span style=color:#111>ref</span><span style=color:#111>(</span><span style=color:#111>permitsCV</span><span style=color:#111>))</span>
</span></span></code></pre></div><p>Identify the <strong>ISOLATED event</strong> to notify; notify absolutely only when needed. To notify:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#111>permitsCV</span><span style=color:#111>.</span><span style=color:#111>notify_all</span><span style=color:#111>();</span>
</span></span></code></pre></div><p>To listen:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#111>permits</span><span style=color:#111>.</span><span style=color:#111>lock</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>while</span> <span style=color:#111>(</span><span style=color:#111>permits</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#111>permitsCV</span><span style=color:#111>.</span><span style=color:#111>wait</span><span style=color:#111>(</span><span style=color:#111>permitsLock</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#111>permits</span><span style=color:#f92672>--</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span><span style=color:#111>permitsLock</span><span style=color:#111>.</span><span style=color:#111>unlock</span><span style=color:#111>();</span>
</span></span></code></pre></div><p>the condition variable will&mldr;</p><ol><li>start sleeping <strong><strong>FIRST</strong></strong></li><li>unlock a lock FOR US <strong><strong>AFTER</strong></strong> the sleeping starts</li><li>after waiting ends, tries to reaquire lock</li><li>blocks until we have the lock again</li></ol><h3 id=unique-lock>unique_lock</h3><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#00a8c8>void</span> <span style=color:#75af00>my_scope</span><span style=color:#111>(</span><span style=color:#111>mutex</span> <span style=color:#f92672>&amp;</span><span style=color:#111>mut</span><span style=color:#111>,</span> <span style=color:#111>condition_variable_any</span> <span style=color:#f92672>&amp;</span><span style=color:#111>cv</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#111>unique_lock</span><span style=color:#f92672>&lt;</span><span style=color:#111>mutex</span><span style=color:#f92672>&gt;</span> <span style=color:#111>lck</span><span style=color:#111>(</span><span style=color:#111>mut</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// do stuff, you can even pass it to a condition variable!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>cv</span><span style=color:#111>.</span><span style=color:#111>wait</span><span style=color:#111>(</span><span style=color:#111>lck</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><h2 id=thread-states-and-contexts>Thread States and Contexts</h2><p>Recall that <a href=/posts/kbhmultithreading/#thread>thread</a>s are the <strong>unit of execution</strong>. The <a href=/posts/kbhprocess_control_block/>process control block</a> keeps track of the <a href=/posts/kbhassembly/#stack-pointer>*stack pointer</a>* of the thread <code>%rsp</code>, which means if a thread is put to sleep the state can be stored somewhere on the stack.</p><p>Three states:</p><ol><li><strong>running</strong> (could switch to ready/blocked)</li><li><strong>ready</strong> able to run, but not on CPU yet (could switch to running <strong>only</strong>)</li><li><strong>blocked</strong> eating for something (could switch to ready/running)</li></ol><h3 id=trap>trap</h3><p>a <a href=/posts/kbhdispatching/#trap>trap</a> is a user request for OS attention explicitly from the user thread, swapping the user process off the CPU.</p><ol><li>system calls</li><li>errors</li><li>page fault (memory errors)</li></ol><h3 id=interrupt>interrupt</h3><p>a <a href=/posts/kbhdispatching/#interrupt>interrupt</a> takes place outside the current thread, it forces the OS&rsquo; attention even if the user thread isn&rsquo;t asking for it</p><ol><li>character typed at keyboard</li><li>completion of a disk operations</li><li>a hardware timer that fires an interrupt</li></ol><h4 id=what-if-a-timer-goes-off-during-an-interrupt--kbhdispatching-dot-md>what if a timer goes off during an <a href=/posts/kbhdispatching/#interrupt>interrupt</a></h4><p><strong>interrupts are disabled during interrupt handling</strong>, otherwise, this causes an infinite loop.</p><h4 id=preemption>preemption</h4><p>We use <a href=/posts/kbhdispatching/#interrupt>interrupt</a>s to implement <a href=/posts/kbhpreemption/>preemption</a>, &ldquo;<a href=/posts/kbhpreemption/>preempting</a>&rdquo; threads in order to swap on another thread to CPU. This enables <a href=/posts/kbhscheduling/>scheduling</a> to happen.</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// brand new thread
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>void</span> <span style=color:#75af00>interrupt_handler</span><span style=color:#111>()</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* disables interupts, automatically by timer handler */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// future spawns start here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>context_switch</span><span style=color:#111>(...);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* enables interupts, automatically by timer handler */</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>void</span> <span style=color:#75af00>threadfunc_wrapper</span><span style=color:#111>()</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// manually enable interrupts before first run
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>intr_enable</span><span style=color:#111>(</span><span style=color:#111>true</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// start thread&#39;s actual business
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#111>threadfunc</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><h2 id=scheduling>Scheduling</h2><h3 id=main-challenges>main challenges</h3><ol><li>minimize time to a useful result&mdash;(<strong>assumption</strong>: a &ldquo;useful result&rdquo; = a thread blocking or completes)</li><li>using resources efficiently (keeping cores/disks busy)</li><li>fairness (multiple users / many jobs for one users)</li></ol><p>We can measure 1) based on &ldquo;average completion time&rdquo;: tracking the average time elapsed for a particular queue based on the start of scheduling that queue to the time when each thread ends.</p><h3 id=main-designs>main designs</h3><h4 id=first-come-first-serve>first-come first-serve</h4><ul><li>keep all threads in ready in a <strong>queue</strong></li><li>run the first thread on the front until it finishes/it blocks for however long</li><li>repeat</li></ul><p><strong>Problem</strong>: a thread can run away with the entire system, accidentally, through infinite loops</p><h4 id=round-robin>round robin</h4><ul><li>keep all threads in a <strong>round robin</strong></li><li>each thread can run for a set amount of time called a <a href=/posts/kbhscheduling/#round-robin>time slice</a> (10ms or so)</li><li>if a thread terminates before that time, great; if a thread does not, we swap it off and put it to the end of the round robin</li></ul><p><strong>Problem</strong>: what&rsquo;s a good <a href=/posts/kbhscheduling/#round-robin>time slice</a>?</p><ul><li>too small: the overhead of context switching is higher than the overhead of running the program</li><li>too large: threads can monopolize cores, can&rsquo;t handle user input, etc.</li></ul><p>Linux uses 4ms. Generally, you want 5-10ms range.</p><h3 id=gold-shortest-remaining-processing-time>gold: shortest remaining processing time</h3><p>Run first the thread in queue that will finish the <strong>most quickly</strong> and run it <strong>fully to competition</strong>.</p><p>It <strong>gives preference to those that need it the least</strong> (i.e. because it runs the smalest one); of course THIS IS <strong>not implementable</strong> without oracle time guess.</p><p>Our goal, then is to get as close as possible to the performance of <a href=/posts/kbhscheduling/#shortest-remaining-processing-time>SRPT</a>.</p><p><strong>Problem</strong>:</p><ol><li>we don&rsquo;t know which one will finish the most quickly</li><li>if we have many threads and one long-running thread, the long running thread won&rsquo;t be able to run ever</li></ol><h3 id=priority-based-scheduling>priority based scheduling</h3><p>Key idea: <strong>behavior tends to be consistent in a thread</strong>. We build multiple <strong>priority queues</strong> to address this.</p><p><a href=/posts/kbhscheduling/#priority-based-scheduling>priority based scheduling</a> is an approximation of <a href=/posts/kbhscheduling/#shortest-remaining-processing-time>SRPT</a>, using the past performance of the thread to estimate the running time of the thread. Over time, <a href=/posts/kbhmultithreading/#thread>thread</a>s will move between priority queues, and we <strong>run the topmost thread from the highest priority queue</strong></p><h4 id=implement-based-on-time-slice--kbhscheduling-dot-md--usage>implement based on <a href=/posts/kbhscheduling/#round-robin>time slice</a> usage</h4><p>a <a href=/posts/kbhmultithreading/#thread>thread</a> always enters in the <strong>highest</strong> priority queue</p><ol><li>if the <a href=/posts/kbhmultithreading/#thread>thread</a> uses all of its <a href=/posts/kbhscheduling/#round-robin>time slice</a> and didn&rsquo;t exit, bump them down a priority queue</li><li>if a <a href=/posts/kbhmultithreading/#thread>thread</a> blocked before it used all of its <a href=/posts/kbhscheduling/#round-robin>time slice</a>, bump them up a priority queue</li></ol><h4 id=implement-based-on-aggregate-time-used-fixing-neglect>implement based on aggregate time used: fixing neglect</h4><p>a <a href=/posts/kbhmultithreading/#thread>thread</a> has a number for &ldquo;how much time did you use on the CPU recently&rdquo;? The priories are sorted by that value, and the smallest time use will be ran.</p><h3 id=context-switch>context switch</h3><ol><li>(in asm) push <strong>all callee saved <a href=/posts/kbhassembly/#register>register</a>s</strong> except <code>%rsp</code> into the bottom of the old thread&rsquo;s <a href=/posts/kbhstack/>stack</a></li><li>store the <a href=/posts/kbhassembly/#stack-pointer>stack pointer</a> <code>%rsp</code> into the <a href=/posts/kbhprocess_control_block/>process control block</a> for that process corresponding to thread</li><li>read the new thread&rsquo;s stack pointer from the <a href=/posts/kbhprocess_control_block/>process control block</a>, and load that into <code>%rsp</code></li><li>(in asm) pop <strong>all callee saved <a href=/posts/kbhassembly/#register>register</a>s</strong> stored on the bottom of our new stack back onto the registers</li></ol><p>To deal with new threads, we create a fake freeze frame on the stack for that new thread which looks like you are just about to call the thread function, and calls <code>context_switch</code> normally.</p><h2 id=virtual-memory>Virtual Memory</h2><h3 id=main-challenges>main challenges</h3><ul><li><strong>multitasking</strong>: multiple processes should be able to use memory</li><li><strong>transparency</strong>: no process need to know that memory is shared; each process should be able to run regardless of the number/locations of processes</li><li><strong>isolation</strong>: processes shouldn&rsquo;t be able to corrupt other processes&rsquo; memory</li><li><strong>efficiency</strong>: shouldn&rsquo;t be degraded by sharing</li></ul><h3 id=crappy-designs-with-no-dmt>crappy designs with no DMT</h3><ul><li><strong>single tasking</strong>: assume there&rsquo;s one process 1) no isolation 2) no multitasking 3) bad fragmentation</li><li><strong>load time relocation</strong>: move the entire program somewhere on load time 1) no isolation 2) can&rsquo;t grow memory after load 3) external fragmentation after frees</li></ul><h3 id=main-designs>main designs</h3><h4 id=base-and-bound>base and bound</h4><p>load time relocation + virtual memory</p><ul><li>assign a location in physical memory, call the <strong>base</strong>; during translation, we just add every virtual address by the <strong>base</strong></li><li>we can cap the virtual address space for each process by a <strong>bound</strong>, we can raise a bus error/segfault if it goes above the highest allowable</li></ul><p><strong>last possible address</strong>: is (bound - 1)+base</p><ol><li>compare virtual address to bound, trap and raise if >= <strong>bound</strong></li><li>then, return virtual address + <strong>base</strong></li></ol><p>tradeoffs: good - 1) inexpensive 2) doesn&rsquo;t need more space 3) ritualized; bad - 1) can&rsquo;t really move either (i.e. need to allocate) 2) fragmentation 3) no read only memory</p><h4 id=multiple-segments>multiple segments</h4><p>break stack, heap, etc. into multiple segments; then do base and bound for each segment</p><p>tradeoffs: good - 1) you can now recycle segments 2) you can not map the middle 3) you can grow the heap (but not the stack, because it moves downwards); bad - 1) you need to decide segment size and location ahead of time</p><h3 id=goal-design>goal design</h3><p>paging: <strong>fixed</strong> segment size, and just split each thing.</p><p>we map each page independently, and keep the offset. If a page is unused, <strong>internal fragmentation</strong> but not too bad. The <strong>stack can now grow downwards</strong>: because if it reaches into lower page numbers we can just map that page somewhere too.</p><p>For instance, typically page sizes are 4kb</p><table><thead><tr><th>Page Size</th><th>Offset Number Digits</th></tr></thead><tbody><tr><td>4096 bytes (16^3)</td><td>3</td></tr></tbody></table><p>then the rest of the address would just be the page number.</p><h4 id=intel-s-implementation>Intel&rsquo;s implementation</h4><p><strong>Virtual Addresses</strong></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Unused (16 bits)</td><td>Virtual page number (36 bits)</td><td>Offset (12 bits)</td></tr></tbody></table><p><strong>Physical Addresses</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Page number (40 bits)</td><td>Offset (12 bits)</td></tr></tbody></table><h4 id=translation>translation</h4><ul><li>chop off page number and offset</li><li>translate the page number</li><li>concat the two together</li></ul><h3 id=implementation>implementation</h3><table><thead><tr><th>Index</th><th>Physical Address</th><th>Writable</th><th>Present/Mapped?</th><th>Last Access</th><th>Kernel</th><th>Dirty</th></tr></thead><tbody><tr><td>0</td><td>0x2023</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0x0023</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><h2 id=swap>Swap</h2><ol><li>pick a page to kick out</li><li>write kicked page to disk</li><li>mark the old page entry as not present</li><li>give the physical address to the new virtual page</li></ol><h3 id=choosing-what-to-swap>choosing what to swap</h3><ul><li>randomly! (works apparently kinda fine)</li><li>First-in-first out (fair, bust bad &mdash; throw out the page in memory longest; but what if its very used)</li><li><strong>least recently used</strong> - clock algorithm</li></ul><h3 id=clock-algorithm>clock algorithm</h3><p><strong>rotate through all pages until we find one that hasn&rsquo;t been referenced since last time</strong></p><ol><li>we add a <strong>reference bit</strong> to the <a href=/posts/kbhvirtual_memory/#paging>page table</a>&mdash;its set to \(1\) if the program wrote or read each page, otherwise its set to \(0\)</li><li>when page kick is needed, clock algorithm starts where it left off before and scan through physical pages<ol><li>each page it checks with reference bit 1, it sets the <strong>reference bit</strong> as 0</li><li>if it checked a page and its reference bit is 0, we kick it out (because we&rsquo;ve gone through two )</li></ol></li></ol><p>We now <strong>save the position of the hand</strong>&mdash;we want to begin checking with the page that hasn&rsquo;t been checked for the longest time. If every page has a <strong>reference bit</strong> is one, running this algorithm doesn&rsquo;t break because it would set its immediately next bit of memory.</p><h3 id=page-replacement>page replacement</h3><ul><li>we <em>don&rsquo;t use</em> <strong>per process replacement</strong> because we need to allocate max pages per process</li><li>we use <strong>global replacement</strong> to maximise usage</li></ul><h3 id=demand-fetching>demand fetching</h3><p>most modern OSes start with <strong>no pages loaded</strong>&mdash;load pages only when referenced; this is tempered by the type of page that&rsquo;s needed:</p><table><thead><tr><th>Page Type</th><th>Need Content on First Load</th><th>Save to Swap (&ldquo;Swap?&rdquo;)</th></tr></thead><tbody><tr><td>code</td><td>yes</td><td>no (read from exe)</td></tr><tr><td>data</td><td>yes</td><td>yes</td></tr><tr><td>stack/heap</td><td>no</td><td>yes</td></tr></tbody></table><p>We only write to disk if its <strong>dirty</strong>.</p><h2 id=multicore-plus-flash>Multicore + Flash</h2><h3 id=scheduling-multi-core-cpus>Scheduling Multi-Core CPUs</h3><h4 id=main-approaches>main approaches</h4><ul><li>one queue for everyone 1) need to figure out what is the priory of things on that queue (for preemption)</li><li>one queue per core: 1) where do we put a thread? 2) how do we move between cores?</li></ul><h4 id=one-ready-queue-per-core>One Ready Queue per Core</h4><ol><li>where do we put a given thread?</li><li>moving core between threads is expensive</li></ol><p>Big tension:</p><ul><li><strong>Work Stealing</strong>: if one core is free (even if there is things in the ready queue), check other cores&rsquo; ready queues and try to do thread communism.</li><li><strong>Core Affinity</strong> ideally, because moving threads between cores is expensive (need to rebuild cache), we keep each thread running on the same core.</li></ul><h4 id=gang-scheduling>Gang Scheduling</h4><p>When you have a thread you are trying to schedule, try to see if there are other threads from the same process in the ready queue and schedule all of them on various cores.</p><h3 id=locking-multi-core-cpus>Locking Multi-Core CPUs</h3><p>disabling interrupts are not enough</p><p><strong>hardware atomic operation</strong> <code>exchange</code> + <strong>busy waiting</strong>, which reads, returns, and swaps the value of some memory in a single atomic operation AND which is never ran in parallel; it returns the previous value of the memory before it was set:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>Lock</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#111>std</span><span style=color:#f92672>::</span><span style=color:#111>automic</span><span style=color:#f92672>&lt;</span><span style=color:#00a8c8>int</span><span style=color:#f92672>&gt;</span> <span style=color:#111>sync</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>void</span> <span style=color:#111>Lock</span><span style=color:#f92672>::</span><span style=color:#111>lock</span><span style=color:#111>()</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>while</span> <span style=color:#111>(</span><span style=color:#111>sync</span><span style=color:#111>.</span><span style=color:#111>exchange</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>))</span> <span style=color:#111>{}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// we are now the only one using it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// do work ....
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#111>sync</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><p>The exchange function returns the old value.</p><h3 id=flash-storage>Flash Storage</h3><h4 id=writing>writing</h4><p>You have two operation.</p><ul><li><strong>erase</strong>: You can set <strong>ALL SEGMENT</strong> of an &ldquo;erase unit&rdquo; to \(1\) (&ldquo;erase unit&rdquo; size is usually 256k)</li><li><strong>write</strong>: You can modify one &ldquo;page&rdquo; at a time (which is smaller than a erase unit)&mdash;but you can ONLY set individual bits in the page into 0 (&ldquo;page&rdquo; size is usually 512 bytes or 4k bytes)</li></ul><h4 id=wear-out>wear-out</h4><p><strong>wear leveling</strong>: make sure that the drive wears out at roughly the same rate as other parts of the drive. Moving commonly written data (&ldquo;hot&rdquo; data) around</p><h4 id=ftl--kbhmodern-os-dot-md--limitations><a href=/posts/kbhmodern_os/#flash-storage>FTL</a> limitations</h4><ul><li>no hardware access (can&rsquo;t optimize around flash storage)</li><li>sacrifices performances for performance</li><li>wasts capacity (to look like hard drive)</li><li>many layers</li></ul><h2 id=ethics>Ethics</h2><p>trusting software is the task of extending your own <strong>AGENCY</strong> to a piece of software: &ldquo;agential gullibility&rdquo;.</p><h3 id=pathways-to-trust>pathways to trust</h3><ul><li><strong>trust by assumption</strong>: 1) trust absent any clues to warrent it due to timing 2) trust because there is imminent danger</li><li><strong>trust by inference</strong>: trust based on information you had before (brands, affiliation, performance)</li><li><strong>trust by substitution</strong>: having a backup plan</li></ul><h3 id=accountability>accountability</h3><p>accountability is in a <strong>chain</strong></p><ul><li>hardware designer (intel)</li><li>OS developer (iOS, ec.)</li><li>app developer</li><li>users</li></ul><h3 id=stakeholder>stakeholder</h3><ol><li><strong>direct stakeholders</strong> (people who are operating, technicians, etc.)</li><li><strong>indirect stakeholders</strong>: patients</li></ol><p>purchase = long-term support &mdash;- what do you do to get it fixed/repaired.</p><h3 id=scales-of-trust>scales of trust</h3><h4 id=scale-of-impact>scale of impact</h4><ul><li>a bug in an OS can be tremendously bad</li><li>&ldquo;root access&rdquo; &mdash; privileged aces</li></ul><h4 id=scale-of-longevity>scale of longevity</h4><ul><li>people maybe on very very old OS</li><li>it requires keeping older OSes secure against modern technologies</li></ul></div></article></main><footer style=margin-top:20px><p id=footer style=font-size:8px;color:var(--gray-3)>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div><script src=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.32.2/tocbot.min.js></script><script>tocbot.init({tocSelector:"#toc",contentSelector:".center-clearfix",headingSelector:"h1, h2, h3",hasInnerContainers:!0})</script></body></html>