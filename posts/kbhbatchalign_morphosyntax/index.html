<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><meta name=viewport content="width=device-width,initial-scale=1"><script src=https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4></script><link rel=preconnect href=https://fonts.bunny.net><link href="https://fonts.bunny.net/css?family=ibm-plex-sans:300,400,400i,500,500i,600,700,700i" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>Batchalign Morphosyntax</title>
<meta name=description content="We now describe the procedure used to perform morpho-syntactic analysis which is used to extract morphological and dependency information, including the morphological features used in this analysis. The core facilities of neural morpho-syntax is provided by the Stanza package ((Qi et al. 2020)), on the basis of which we perform myriad customizations in order to support the analysis functionality needed for this work.
The process of morpho-syntax analysis occurs in five basic steps: 1) performance of raw language sample analysis (LSA) using automatic speech recognition (ASR) and utterance segmentation tools already built into the Batchalign system ((Liu et al. 2023)) 2) use of the Stanza tokenizer and multi-word token (MWT) recognizer to obtain initial word-level tokenization of each utterance 3) programmatic, language-specific correction of these tokenization, especially pertaining to multi-word tokens (MWTs) and multi-word forms 4) the invocation of the rest of the Stanza neural pipeline for morphology, dependency, and feature extraction 5) programmatic extraction and correction of output features after the Stanza pipeline."><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/all.css><link rel=stylesheet href=/css/page.css><link rel=stylesheet href=/css/syntax.css><link rel=stylesheet href=/css/typography.css><link rel=stylesheet href=/css/components.css></head><body><div class="center-clearfix p-10" style="max-width:1200px;margin:0 auto"><header class=pb-4><span class="w-full flex justify-between flex-wrap"><div style=font-weight:600;font-size:15px><a style=border:0;cursor:pointer href=/><img src=/images/Logo_Transparent.png style=width:17px;display:inline-block;margin-right:8px;transform:translateY(-2.7px)></a>Batchalign Morphosyntax</div><span style="float:right;display:flex;align-items:center;margin-top:5px;width:100%;max-width:400px;background:#fff;border-radius:2px;border:1px solid var(--gray-2);position:relative"><i class="fa-solid fa-magnifying-glass" style=font-size:12px;color:var(--yellow-fg);margin-right:7px;margin-left:10px></i><div style=width:100%><input id=search-query-inline name=s type=text autocomplete=off placeholder="Search Knowledgebase" enterkeyhint=search></div><div id=search-result-inline style=display:none></div><script id=search-result-template type=text/x-js-template data-template=searchresult>
    <a href="${link}" class="search-link">
    <div class="search-result-item" id="search-result-item-${key}">
        <div class="search-result-title">${title}</div>
        <div class="search-result-summary">${snippet}</div>
    </div>
    </a>
</script><script src=https://code.jquery.com/jquery-3.3.1.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.0/fuse.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js></script><script type=module>
    import { create, insertMultiple, search } from 'https://cdn.jsdelivr.net/npm/@orama/orama@latest/+esm'
    let template = $('script[data-template="searchresult"]').text().split(/\$\{(.+?)\}/g);

    function render(props) {
        return function(tok, i) { return (i % 2) ? props[tok] : tok; };
    }

    const db = create({
        schema: {
            title: 'string',
            content: 'string',
        },
    });
    $.get("https://www.jemoka.com/index.json", function(data, status){
        insertMultiple(db, data.map(x =>
            ({title: x.title, content: x.contents, link: x.permalink})));
    });
    $("#search-result-inline").attr("tabindex", "-1");
    $(document).on("click", function (e) {
    if (!$(e.target).closest("#search-query-inline, #search-result-inline").length) {
        $("#search-result-inline").hide();
    }
    });
    
    
    
    
    
    

    $("#search-query-inline").on("focus keyup", function () {
        let value = $(this).val();
        if (value.trim() == "") {
            $("#search-result-inline").html("");
            $("#search-result-inline").hide();
            return;
        }
        $("#search-result-inline").show();
        let results = search(db, {mode: "fulltext", term: value});
        let contents = results.hits.map(x => template.map(render({
            title: x.document.title,
            snippet: x.document.content.slice(0, 52),
            key: x.id,
            link: x.document.link
        })).join(''));
        $("#search-result-inline").html(contents.join("\n"));
        
    });
    if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        $('#search-query-inline').on('focus', function(){
            
            $(this).data('fontSize', $(this).css('font-size')).css('font-size', '16px');
        }).on('blur', function(){
            
            $(this).css('font-size', $(this).data('fontSize'));
        });
    }

</script></span></span><div class=w-full style="padding-bottom:4px;border-bottom:1px solid var(--gray-1);margin-top:1px"></div></header><aside id=tocbox><div id=heading style=padding-left:40px;font-weight:600;font-size:11px;color:var(--gray-3)>contents</div><div id=toc></div></aside><main><article><div style=max-width:700px><p>We now describe the procedure used to perform morpho-syntactic analysis which is used to extract morphological and dependency information, including the morphological features used in this analysis. The core facilities of neural morpho-syntax is provided by the Stanza package ((<a href=#citeproc_bib_item_11>Qi et al. 2020</a>)), on the basis of which we perform myriad customizations in order to support the analysis functionality needed for this work.</p><p>The process of morpho-syntax analysis occurs in five basic steps: 1) performance of raw language sample analysis (LSA) using automatic speech recognition (ASR) and utterance segmentation tools already built into the Batchalign system ((<a href=#citeproc_bib_item_6>Liu et al. 2023</a>)) 2) use of the Stanza tokenizer and multi-word token (MWT) recognizer to obtain initial word-level tokenization of each utterance 3) programmatic, language-specific correction of these tokenization, especially pertaining to multi-word tokens (MWTs) and multi-word forms 4) the invocation of the rest of the Stanza neural pipeline for morphology, dependency, and feature extraction 5) programmatic extraction and correction of output features after the Stanza pipeline.</p><h2 id=initial-language-sample-analysis>Initial Language Sample Analysis</h2><p>Because the rest of the analysis we describe in this work takes place at a textual level, we first must extract text from the original auditory language samples. This step of the analysis occurs using the Batchalign system ((<a href=#citeproc_bib_item_6>Liu et al. 2023</a>)), and specifically its facilities for ASR and utterance segmentation. We describe here briefly the high-level options available as a part of the Batchalign ASR system relevant to the downstream analysis which we present; specific details of the system is described in further detail in publication regarding the system itself.</p><p>To perform the initial ASR, Batchalign offers two methods; users can select either the use of a commercial ASR service, Rev.AI (training supervized by (<a href=#citeproc_bib_item_3>Del Rio et al. 2022</a>)), or a local ASR model based on OpenAI Whisper ((<a href=#citeproc_bib_item_12>Radford et al. 2022</a>)).</p><p>Though the choice of ASR system is largely irrelevant to downstream analysis, it is critical to note that&mdash;because the orthography of Universal Dependencies training data for the Stanza models used in our analysis here uses native orthographies ((<a href=#citeproc_bib_item_11>Qi et al. 2020</a>; <a href=#citeproc_bib_item_2>De Marneffe et al. 2021</a>))&mdash;latinized transcripts must be converted back into their original orthography before downstream analysis.</p><p>Because of this limitation, the significantly wider language and orthographic profile of the Whisper model (in particular, WhisperV3 available at <a href=https://huggingface.co/openai/whisper-large-v3>https://huggingface.co/openai/whisper-large-v3</a>) is advantageous for non-English languages; therefore, the majority of the recognition needed to cover all the languages described here (and in particular ones with non-latinized native orthography) is performed with the Whisper option.</p><p>After ASR, the Batchalign system has the capability to perform text-based utterance segmentation&mdash;useful to maintain the standardization metrics such as MLU or mean features per utterance. For English and Mandarin, Batchalign uses a Bert ((<a href=#citeproc_bib_item_5>Devlin et al. 2019</a>)) style token classification model for the task of utterance segmentation which is trained in the manner previously described in (<a href=#citeproc_bib_item_6>Liu et al. 2023</a>). For other languages, Batchalign relies on the sentence-level text segmentation produced by Whisper model as a baseline for utterance segmentation.</p><h2 id=morpho-syntactic-analysis>Morpho-Syntactic Analysis</h2><p>The rest of the morpho-syntax analysis described here follows largely the principles outlined by the Universal Dependencies (UD) project ((<a href=#citeproc_bib_item_2>De Marneffe et al. 2021</a>)), and is performed largely by the neural analysis models given by the Stanza ((<a href=#citeproc_bib_item_11>Qi et al. 2020</a>)) system. However, to ensure a consistent analysis, we now describe some key deviations and modifications we make to the end-to-end Stanza system.</p><p>After LSA, the rest of the analysis takes place at the utterance level. This consequentially means that there is no continuation of analyses between different utterances&mdash;for instance, a dependency between two forms cannot span across utterances even if they belong to the same sentence. To implement this, we simply treat each utterance as a &ldquo;sentence&rdquo; to be analyzed by Stanza.</p><h3 id=tokenization>Tokenization</h3><p>The first step of analysis involves tokenizing each utterance into tokens. Because the CHAT transcription format ((<a href=#citeproc_bib_item_8>MacWhinney 2014</a>)) largely encodes tokenization by using whitespace delineated token groups to identify words, tokenization is frequently given natively in the transcript.</p><p>This is, however, untrue in some languages whose token representations have little to do with word-level representations. In Japanese child language, for instance, two of the language&rsquo;s three writing systems&mdash;hiragana and katakana&mdash;are moraic-based units frequently employed to transcribe a child during L1 development ((<a href=#citeproc_bib_item_10>Ota 2015</a>)) while the third&mdash;kanji, often used for actual word representations needed for morpho-syntax analysis, have little to do with phonology. Because of this, whitespace-delineated token representations are not suitable as a source of information for word representations.</p><p>For languages which has this limitation, we employ the more complex token segmentation scheme given in Stanza which involves formulating word-level tokenization as a token labeling task&mdash;ignoring any transcribed tokenizations, labeling each input <em>character</em> as belonging to the start, middle, or end of a token&mdash;before further processing each resulting &ldquo;token group&rdquo; via the downstream, semantic aware modules such as the Stanza lemmatizer. In this way, we recover a canonical tokenization for those particular languages based on the annotation style chosen by the working group of the target language in UD annotation; for Japanese, for instance, this may include some resulting orthographic Kanji formed by joining tokens from other syllabaries following the short-unit word (SUW) style ((<a href=#citeproc_bib_item_4>Den et al. 2008</a>)). We then use this canonical tokenization to &ldquo;retokenize&rdquo; the original CHAT transcript with this new tokenization.</p><p>Once this initial tokenization is obtained, we can then proceed to the remaining analysis by the pipeline describe here.</p><h3 id=multi-word-token-and-form-correction>Multi-Word Token and Form Correction</h3><p>Following the convention of UD ((<a href=#citeproc_bib_item_2>De Marneffe et al. 2021</a>)), there is a distinction to be made between tokens&mdash;continuous character spans without delineation in between&mdash;and syntactic words used in analysis.</p><p>This distinction is relevant in particular with respect to the treatment of &ldquo;multi-word tokens&rdquo; (MWTs)&mdash;a single continuous text span which contains multiple syntactic words, each with individual features and dependencies which needs to be analyzed independently.</p><p>Augmenting Stanza&rsquo;s neural-only analysis, we use a lexicon and orthography driven approach to identify and expand three types of such MWTs.</p><p>Two types of such MWTs are usually automatically recognized by Stanza through the same tokenization procedure described in the section above: clitics and contractions. Clitics are independent syntactical forms attached to other words, such as in Spanish <em>despertarme</em> (<em>despertar</em> + <em>me</em>)&mdash;with the latter being a separate syntactic word which modifies the previous word which needs to be analyzed independently (i.e. modifying that I am who woke the object up); contractions are combinations of multiple words into one token, such as in English <em>I&rsquo;m</em> (<em>I</em> + <em>am</em>).</p><p>If clitics and contractions are not automatically expanded by Stanza, we use a rules-based analysis of orthography to detect these some of these common forms and manually expand them. This functionality is currently supported for detection of the subject contractions in French and Italian (i.e. <em>l&rsquo;amor</em> to <em>le</em> + amor/, <em>t&rsquo;aime</em> to <em>te</em> + <em>aime</em>) through detecting apostrophe and matching the first form to a lexicon, prepositional contractions (i.e. <em>jusqu&rsquo;ici</em> to <em>jusque</em> + <em>ici</em>) in a similar manner, and be-contractions in English (i.e. <em>you&rsquo;re</em> to <em>you</em> + <em>are</em>).</p><p>The third type of MWT not typically expanded by Stanza, but which our pipeline uses a lexicon to detect and expand, are single-unit, multi-word forms which are usually joined by an underscore in the CHAT transcription format ((<a href=#citeproc_bib_item_8>MacWhinney 2014</a>)) because they are a single semantic form and multiple syntactic words. For instance, the form <em>pirates_des_Caraïbes</em> is one such form, broken into <em>pirates</em> <em>des</em> <em>Caraïbes</em>.</p><p>We implement this correction functionality by implementing a custom step in the Stanza analysis pipeline; this step takes the &ldquo;draft&rdquo; tokenizations from Stanza as input, and will return the correct tokenization and word expansions to downstream analysis functions in Stanza&mdash;ensuring that morphologies, features, and dependencies will be analyzed on the <em>corrected</em> word.</p><p>Additionally, the neural tokenizer in Stanza would occasionally mark forms as MWTs when they are simply single-token single-word forms with a punctuation within (i.e. the French word <em>aujourd&rsquo;hui</em>); in those cases, we perform the opposite correction forcing Stanza to treat the resulting token a single word instead of an MWT. These cases are identified and corrected using a lexicon as well.</p><p>In final output into the CHAT transcription format, we follow the convention set forth by the CLAN MOR/MEGRASP system ((<a href=#citeproc_bib_item_7>MacWhinney 2012</a>)) and join the morphology analyses of multi-word tokens together with a tilde (~), maintaining token-level alignment between the transcript and analysis yet being able to encode multiple words within a token.</p><h3 id=morphology-and-dependency-analysis>Morphology and Dependency Analysis</h3><p>In our work, we make no further adjustments to the Stanza morphology, dependency, and feature analysis of each language and simply run the remaining Stanza analysis pipeline with the corrected tokens.</p><p>Notably, because of the Stanza models are largely trained via the Universal Dependencies ((<a href=#citeproc_bib_item_2>De Marneffe et al. 2021</a>)) dataset, some datasets (such as UD Dutch Alpino by (<a href=#citeproc_bib_item_1>Bouma, Van Noord, and Malouf 2001</a>)) will be rich in annotated feature information whereas some others (such as UD Japanese GSD in (<a href=#citeproc_bib_item_9>Nivre et al. 2020</a>)) will have little to no features annotated. Our UD analysis, therefore, carries the design choices of analysis made within these gold datasets.</p><p>Once these morphology, dependency, and feature information has been annotated by the Stanza system, we proceed to perform morphology-dependent extraction and correction of the resulting features as a final processing step.</p><h3 id=morpho-syntax-transcription-and-feature-correction>Morpho-syntax Transcription and Feature Correction</h3><p>After analysis by Stanza, we operationalize the extracted features using an annotation format very similar to the one used in the MOR/MEGRASP system (described further in <a href=https://talkbank.org/manuals/mor.pdf>https://talkbank.org/manuals/mor.pdf</a>) within the <em>%mor</em> and <em>%gra</em> lines in CHAT.</p><p>Though the annotation format largely follows MOR and MEGRASP, our analysis here deviate in two key ways. First, we use part-of-speech tags conforming to the Universal POS tags (UPOS) as well as dependency relations annotated via the UD convention instead of that of MEGRASP.</p><p>Furthermore, we make some adjustments to the method by which morphological features are presented which takes components from both the typical style of both MOR and UD.</p><p>As mentioned above, there exists variations as to which features are available which differs for each language being analyzed. Therefore, our overaching goal is to report the <em>maximal set</em> of features which 1) can be reported for each language and 2) provide additional information beyond the &ldquo;default&rdquo; case.</p><p>In service to this, aspect, mood, tense, polarity, clusivity, case, type, degree, conjugation (form), and politeness are reported for their respective corresponding morphologies as-available and as-annotated directly following the UD annotation specifications; gender is reported for all tagged genders beyond &ldquo;common neutral&rdquo; (ComNeut); and number is reported for all beyond singular. Importantly, for personhood, fourth and zeroth person are resolved to be reported as &ldquo;fourth person&rdquo;&mdash;as in, the impersonal and alternate-third persons are not distinguished; first, second, and third persons are preserved as is.</p><p>The annotated features, similar to MOR, are joined using a dash &ldquo;-&rdquo; after the lemma of the form being tagged in the <em>%mor</em> line.</p><h2 id=data-and-software-availability>Data and Software Availability</h2><p>The analysis described here has been integrated as a processing module in a revised version of the Batchalign system, named Batchalign2, which is available to be used by visiting <a href=https://github.com/talkbank/batchalign2>https://github.com/talkbank/batchalign2</a>.</p><p>The utterance segmentation models trained using the manner described in ((<a href=#citeproc_bib_item_6>Liu et al. 2023</a>)) are additionally available for US english and mandarin; these models are available at <a href=https://huggingface.co/talkbank>https://huggingface.co/talkbank</a>.</p></div></article></main><footer style=margin-top:20px><p id=footer style=font-size:8px;color:var(--gray-3)>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div><script src=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.32.2/tocbot.min.js></script><script>tocbot.init({tocSelector:"#toc",contentSelector:".center-clearfix",headingSelector:"h1, h2, h3",hasInnerContainers:!0})</script></body></html>