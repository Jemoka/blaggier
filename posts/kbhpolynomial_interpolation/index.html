<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin=anonymous></script><meta name=viewport content="width=device-width,initial-scale=1"><script src=https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4></script><link rel=preconnect href=https://fonts.bunny.net><link href="https://fonts.bunny.net/css?family=ibm-plex-sans:300,400,400i,500,500i,600,700,700i" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>window.MathJax={loader:{load:["[tex]/physics"]},tex:{packages:{"[+]":["physics"]}}}</script><title>polynomial interpolation</title>
<meta name=description content="constituents
\(m\) data points \(\qty(x_i,y_{i})\)
requirements
we desire \(c_{j}\) such that:
\begin{equation}
y = c_1 + c_{2} x + c_3 x^{2} + \dots
\end{equation}
Given our set of basis functions \(\phi_{j}(x)\) for input \(x\), our goal is:
\begin{equation}
y = c_1 \phi_{1} + c_2 \phi_{2} + \dots + c_{n}\phi_{n}
\end{equation}
the \(\phi\) are the model function which determines our neural networks.
additional information
Monomial basis and vandermonde Matrix
to do this, we put stuff in matrix form following forms, called the matrix of monomial basis:"><meta name=author content="Houjun Liu"><link rel=stylesheet href=/css/all.css><link rel=stylesheet href=/css/page.css><link rel=stylesheet href=/css/syntax.css><link rel=stylesheet href=/css/typography.css><link rel=stylesheet href=/css/components.css></head><body><div class="center-clearfix p-10" style="max-width:1200px;margin:0 auto"><header class=pb-4><span class="w-full flex justify-between flex-wrap"><div style=font-weight:600;font-size:15px><a style=border:0;cursor:pointer href=/><img src=/images/Logo_Transparent.png style=width:17px;display:inline-block;margin-right:8px;transform:translateY(-2.7px)></a>polynomial interpolation</div><span style="float:right;display:flex;align-items:center;margin-top:5px;width:100%;max-width:400px;background:#fff;border-radius:2px;border:1px solid var(--gray-2);position:relative"><i class="fa-solid fa-magnifying-glass" style=font-size:12px;color:var(--yellow-fg);margin-right:7px;margin-left:10px></i><div style=width:100%><input id=search-query-inline name=s type=text autocomplete=off placeholder="Search Knowledgebase" enterkeyhint=search></div><div id=search-result-inline style=display:none></div><script id=search-result-template type=text/x-js-template data-template=searchresult>
    <a href="${link}" class="search-link">
    <div class="search-result-item" id="search-result-item-${key}">
        <div class="search-result-title">${title}</div>
        <div class="search-result-summary">${snippet}</div>
    </div>
    </a>
</script><script src=https://code.jquery.com/jquery-3.3.1.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.0/fuse.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js></script><script type=module>
    import { create, insertMultiple, search } from 'https://cdn.jsdelivr.net/npm/@orama/orama@latest/+esm'
    let template = $('script[data-template="searchresult"]').text().split(/\$\{(.+?)\}/g);

    function render(props) {
        return function(tok, i) { return (i % 2) ? props[tok] : tok; };
    }

    const db = create({
        schema: {
            title: 'string',
            content: 'string',
        },
    });
    $.get("https://www.jemoka.com/index.json", function(data, status){
        insertMultiple(db, data.map(x =>
            ({title: x.title, content: x.contents, link: x.permalink})));
    });
    $("#search-result-inline").attr("tabindex", "-1");
    $(document).on("click", function (e) {
    if (!$(e.target).closest("#search-query-inline, #search-result-inline").length) {
        $("#search-result-inline").hide();
    }
    });
    
    
    
    
    
    

    $("#search-query-inline").on("focus keyup", function () {
        let value = $(this).val();
        if (value.trim() == "") {
            $("#search-result-inline").html("");
            $("#search-result-inline").hide();
            return;
        }
        $("#search-result-inline").show();
        let results = search(db, {mode: "fulltext", term: value});
        let contents = results.hits.map(x => template.map(render({
            title: x.document.title,
            snippet: x.document.content.slice(0, 52),
            key: x.id,
            link: x.document.link
        })).join(''));
        $("#search-result-inline").html(contents.join("\n"));
        
    });
    if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        $('#search-query-inline').on('focus', function(){
            
            $(this).data('fontSize', $(this).css('font-size')).css('font-size', '16px');
        }).on('blur', function(){
            
            $(this).css('font-size', $(this).data('fontSize'));
        });
    }

</script></span></span><div class=w-full style="padding-bottom:4px;border-bottom:1px solid var(--gray-1);margin-top:1px"></div></header><aside id=tocbox><div id=heading style=padding-left:40px;font-weight:600;font-size:11px;color:var(--gray-3)>contents</div><div id=toc></div></aside><main><article><div style=max-width:700px><h2 id=constituents>constituents</h2><p>\(m\) data points \(\qty(x_i,y_{i})\)</p><h2 id=requirements>requirements</h2><p>we desire \(c_{j}\) such that:</p><p>\begin{equation}
y = c_1 + c_{2} x + c_3 x^{2} + \dots
\end{equation}</p><p>Given our set of basis functions \(\phi_{j}(x)\) for input \(x\), our goal is:</p><p>\begin{equation}
y = c_1 \phi_{1} + c_2 \phi_{2} + \dots + c_{n}\phi_{n}
\end{equation}</p><p>the \(\phi\) are the <a href>model function</a> which determines our <a href=/posts/kbhdeep_learning/>neural network</a>s.</p><h2 id=additional-information>additional information</h2><h3 id=monomial-basis-and-vandermonde-matrix>Monomial basis and vandermonde Matrix</h3><p>to do this, we put stuff in matrix form following forms, called the matrix of <a href=/posts/kbhpolynomial_interpolation/>monomial basis</a>:</p><p>\begin{equation}
\mqty(1 & x_1 & x_1^{2} \\ 1 & x_2 & x_2^{2} \\ & \dots &) \mqty(c_1 \\ c_2 \\ c_3) = \mqty(y_1 \\ y_2 \\ y_3)
\end{equation}</p><p>inverting this matrix gives us the answer; this is the <a href=/posts/kbhpolynomial_interpolation/>Vandermonde</a> matrix. See <a href=#problem-with-vandermonde--kbhpolynomial-interpolation-dot-md--martix>problem with Vandermonde martix</a></p><h3 id=lagrange-basis>Lagrange Basis</h3><p>\begin{equation}
\phi_{k} \qty(x) = \frac{\prod_{i\neq k}^{} x-x_{i}}{\prod_{i \neq k}^{} x_{k}- x_{i}}
\end{equation}</p><p>notice this gives a \(A\) as an identity, but evaluation time is more expensive because you have to do all the multiplication in sequence.</p><p>This also has no problem of being ill-conditioned unlike the <a href=/posts/kbhpolynomial_interpolation/>Vandermonde</a> matrix.</p><p>However, each term is now quadratic.</p><h3 id=newton-basis>Newton Basis</h3><p>\begin{equation}
\phi_{k} \qty(x) = \prod_{i=1}^{k-1} x - x_{i}
\end{equation}</p><p>the first entry is \(1\), the second entry is quadratic, and so on. This is now only quadratic in one term up to \(k=3\).</p><h3 id=overfitting>overfitting</h3><p>For \(m\) data points, you can draw a unique \(m-1\), polynomial which fits the lines exactly.</p><p><a href=/posts/kbhoverfitting/>overfitting</a> can occur, so we perform <a href=/posts/kbhregularization/>regularization</a></p><p>We do this as long as they are not <strong>degenerate</strong>: your points can&rsquo;t be on a line.</p><h3 id=problem-with-vandermonde--kbhpolynomial-interpolation-dot-md--martix>problem with <a href=/posts/kbhpolynomial_interpolation/>Vandermonde</a> martix</h3><p>at higher powers, the squared results tend to be more parallel: this is bad because then small parameter adjustments will require humongous parameter values</p><ul><li>and if two columns of the matrix are parallel, our rank would be at most \(n-1\)</li><li>&mldr;meaning we don&rsquo;t span \(\mathbb{R}^{n}\)</li><li>&mldr;we may not have a solution! because some target output in \(\mathbb{R}^{n}\) may not be hit, or could be hit many times by manipulating the parallel vectors</li></ul><p>in general: if any columns become linearly dependent, they maybe combined in infinite number of ways; that is, we want our Vandermode matrix to have full rank.</p><h4 id=near-singular-matrix-problem>near-singular matrix problem</h4><p><strong>importantly</strong>: if its even <em>close</em> to being singular, we will have this problem.</p><ul><li>with limited precision, we will struggle when columns/linear combinations of columns are too close to being parallel</li><li>they may not be computationally invertible</li><li><a href=/posts/kbhrobustness/>condition number</a>s can help judge how close our matrix is about to be non-invertible</li></ul></div></article></main><footer style=margin-top:20px><p id=footer style=font-size:8px;color:var(--gray-3)>&copy; 2019-2025 Houjun Liu. Licensed CC BY-NC-SA 4.0.</p></footer></div><script src=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.32.2/tocbot.min.js></script><script>tocbot.init({tocSelector:"#toc",contentSelector:".center-clearfix",headingSelector:"h1, h2, h3",hasInnerContainers:!0})</script></body></html>